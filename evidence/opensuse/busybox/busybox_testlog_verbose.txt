======================
echo -ne '' >input
echo -ne '' | ./unknown 2>&1
PASS: busybox as unknown name
======================
echo -ne '' >input
echo -ne '' | true | busybox --help busybox 2>&1 | cat
PASS: busybox --help busybox
======================
echo -ne '' >input
echo -ne '' | busybox 2>&1 | cat
PASS: busybox
======================
echo -ne '' >input
echo -ne '' | busybox unknown 2>&1
PASS: busybox unknown
======================
echo -ne '' >input
echo -ne '' | busybox --help 2>&1
PASS: busybox --help
======================
echo -ne '' >input
echo -ne 'moo' | busybox cat
PASS: busybox cat
======================
echo -ne '' >input
echo -ne '' | busybox --help cat 2>&1 | grep Print
PASS: busybox --help cat
======================
echo -ne '' >input
echo -ne '' | busybox --help unknown 2>&1
PASS: busybox --help unknown
======================
echo -ne '' >input
echo -ne '' | ./busybox-suffix 2>&1 | cat
PASS: ./busybox-suffix
======================
echo -ne '' >input
echo -ne '' | ./busybox-suffix unknown 2>&1
PASS: ./busybox-suffix unknown
======================
echo -ne '' >input
echo -ne '' | ./busybox-suffix --help 2>&1
PASS: ./busybox-suffix --help
======================
echo -ne '' >input
echo -ne 'moo' | ./busybox-suffix cat
PASS: ./busybox-suffix cat
======================
echo -ne '' >input
echo -ne '' | ./busybox-suffix --help cat 2>&1 | grep Print
PASS: ./busybox-suffix --help cat
======================
echo -ne '' >input
echo -ne '' | ./busybox-suffix --help unknown 2>&1
PASS: ./busybox-suffix --help unknown
======================
echo -ne '' >input
echo -ne '' | ar rc test.a README && ar p test.a README | md5sum
PASS: ar creates archives
======================
echo -ne '' >input
echo -ne '' | echo 'blah!' >file1 && echo 'blast!' >file2 && ar cr test.a README file1 file2 && mv file2 file1 && ar cr test.a file1 && ar p test.a file1
PASS: ar replaces things in archives
======================
echo -ne '' >input
echo -ne '' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 0
======================
echo -ne '' >input
echo -ne '\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 1
======================
echo -ne '' >input
echo -ne '#\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 2
======================
echo -ne '' >input
echo -ne '#abc#\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 3
======================
echo -ne '' >input
echo -ne '#abc#zz\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 4
======================
echo -ne '' >input
echo -ne '#abc##zz\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 5
======================
echo -ne '' >input
echo -ne 'z#abc##zz\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 6
======================
echo -ne '' >input
echo -ne 'z##abc##zz\n' | awk -F '[#]' '{ print NF }'
PASS: awk -F case 7
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{if(23==23) print "foo"}'
PASS: awk if operator == 
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{if(23!=23) print "bar"}'
PASS: awk if operator != 
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{if(23>=23) print "foo"}'
PASS: awk if operator >= 
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{if(2 < 13) print "foo"}'
PASS: awk if operator < 
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{if("a"=="ab") print "bar"}'
PASS: awk if string == 
======================
echo -ne '' >input
echo -ne '\n' | awk '{ print or(4294967295,1) }'
PASS: awk bitwise op
======================
echo -ne '' >input
echo -ne '' | awk '
function empty_fun(count) {
  # empty
}
END {
  i=1
  print "L" i "\n"
  empty_fun(i + i + ++i)
  print "L" i "\n"
}'
PASS: awk handles empty function f(arg){}
======================
echo -ne '' >input
echo -ne '' | awk '
function empty_fun(){}
END {empty_fun()
  print "Ok"
}'
PASS: awk handles empty function f(){}
======================
echo -ne '' >input
echo -ne '' | awk '
function outer_fun() {
  return 1
}
END {
  i=1
  print "L" i "\n"
  i += outer_fun()
  print "L" i "\n"
}'
PASS: awk properly handles function from other scope
======================
echo -ne '' >input
echo -ne '' | awk '
END {
  i=1
  print "L" i "\n"
  i + trigger_error_fun()
  print "L" i "\n"
}' 2>&1
PASS: awk properly handles undefined function
======================
echo -ne '' >input
echo -ne '' | awk '
BEGIN {
  v=1
  a=2
  print v (a)
}' 2>&1
PASS: awk 'v (a)' is not a function call, it is a concatenation
======================
echo -ne '' >input
echo -ne '' | awk 'func f(){print"F"};func g(){print"G"};BEGIN{f(g(),g())}' 2>&1
PASS: awk unused function args are evaluated
======================
echo -ne '' >input
echo -ne '\n' | awk '{ print or(0xffffffff,1) }'
PASS: awk hex const 1
======================
echo -ne '' >input
echo -ne '\n' | awk '{ print or(0x80000000,1) }'
PASS: awk hex const 2
======================
echo -ne '' >input
echo -ne '\n' | awk '{ print or(01234,1) }'
PASS: awk oct const
======================
echo -ne '' >input
echo -ne '\n' | awk '{ printf "%f %f\n", "000.123", "009.123" }'
PASS: awk floating const with leading zeroes
======================
echo -ne '' >input
echo -ne 'a--\na--b--\na--b--c--\na--b--c--d--' | awk -F-- '{ print NF, length($NF), $NF }'
PASS: awk long field sep
======================
echo -ne '' >input
echo -ne 'a!b\n' | awk -F'\x21' '{print $1}'
PASS: awk -F handles escapes
======================
echo -ne '' >input
echo -ne 'Hi\n' | awk 'gsub("@(samp|code|file)\{","");'; echo $?
PASS: awk gsub falls back to non-extended-regex
======================
echo -ne '' >input
echo -ne '' | awk -f awk_t1_opt-functions.awk -f awk_t1_opth-gen.awk <awk_t1_input | md5sum
PASS: awk 'gcc build bug'
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { print ":" NF ":" $0 ":" $1 ":" $2 ":" }'
PASS: awk NF in BEGIN
======================
echo -ne '' >input
echo -ne '' | awk '
function b(tmp) {
tmp = 0;
print "" tmp; #this line causes the bug
return tmp;
}
function c(tmpc) {
tmpc = b(); return tmpc;
}
BEGIN {
print (c() ? "string" : "number");
}'
PASS: awk string cast (bug 725)
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { arr [3] = 1; print arr [3] }'
PASS: awk handles whitespace before array subscript
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { getline line <"doesnt_exist"; print ERRNO; ERRNO=0; close("doesnt_exist"); print ERRNO; print "Ok" }'
PASS: awk handles non-existing file correctly
======================
echo -ne '' >input
echo -ne '' | awk '
BEGIN {
  u["a"]=1
  u["b"]=1
  u["c"]=1
  v["d"]=1
  v["e"]=1
  v["f"]=1
  for (l in u) {
    print "outer1", l;
    for (l in v) {
      print " inner", l;
    }
    print "outer2", l;
  }
  print "end", l;
  l="a"
  exit;
}'
PASS: awk nested loops with the same variable
======================
echo -ne '' >input
echo -ne '' | awk '
BEGIN{
cnt = 0
a[cnt] = "zeroth"
a[++cnt] = "first"
delete a[cnt--]
print cnt
print "[0]:" a[0]
print "[1]:" a[1]
}'
PASS: awk 'delete a[v--]' evaluates v-- once
======================
echo -ne '' >input
echo -ne '' | awk 'func f(,) { }' 2>&1
PASS: awk func arg parsing 1
======================
echo -ne '' >input
echo -ne '' | awk 'func f(a,,b) { }' 2>&1
PASS: awk func arg parsing 2
======================
echo -ne '' >input
echo -ne '' | awk 'func f(a,) { }' 2>&1
PASS: awk func arg parsing 3
======================
echo -ne '' >input
echo -ne '' | awk 'func f(a b) { }' 2>&1
PASS: awk func arg parsing 4
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN {print()}' 2>&1
PASS: awk handles empty ()
======================
echo -ne '' >input
echo -ne 'a:b c:d\ne:f g:h' | awk '{FS=":"; print $1}'
PASS: awk FS assignment
SKIPPED: awk large integer
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN{ A[1]=2; A["qwe"]="asd"; print length(A)}'
PASS: awk length(array)
======================
echo -ne '' >input
echo -ne 'qwe' | awk '{print length; print length(); print length("qwe"); print length(99+9)}'
PASS: awk length()
======================
echo -ne '' >input
echo -ne '\n' | awk '{ print length, 1 }'
PASS: awk print length, 1
======================
echo -ne '' >input
echo -ne '\n' | awk '{ print length 1 }'
PASS: awk print length 1
======================
echo -ne '' >input
echo -ne '\n' | awk 'length == 0 { print "foo" }'
PASS: awk length == 0
======================
echo -ne '' >input
echo -ne '\n' | awk '{ if (length == 0) { print "bar" } }'
PASS: awk if (length == 0)
======================
echo -ne 'do re mi\n' >input
echo -ne '{print $2; print ARGC;}' | awk -f - input
PASS: awk -f and ARGC
======================
echo -ne 'do re mi\n' >input
echo -ne '' | awk -e '{print $2; print ARGC;}' input
PASS: awk -e and ARGC
======================
echo -ne '' >input
echo -ne 'BEGIN { if (1) break; else a = 1 }' | awk -f - 2>&1; echo $?
PASS: awk break
======================
echo -ne '' >input
echo -ne 'BEGIN { if (1) continue; else a = 1 }' | awk -f - 2>&1; echo $?
PASS: awk continue
======================
echo -ne '' >input
echo -ne '' | awk -e '{ for() }' 2>&1
PASS: awk handles invalid for loop
======================
echo -ne '' >input
echo -ne '' | awk -e foo:bar: 2>&1
PASS: awk handles colon not preceded by ternary
======================
echo -ne '' >input
echo -ne '' | awk -e '{delete}' 2>&1
PASS: awk errors on missing delete arg
======================
echo -ne '' >input
echo -ne '\n' | awk '{printf("hello%c null\n", 0)}'
PASS: awk printf('%c') can output NUL
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { printf "[%-10c]\n", 0 }' | od -tx1
PASS: awk printf('%-10c') can output NUL
======================
echo -ne '' >input
echo -ne 'anything' | awk 2>&1 -- '{ $(-1) }'
PASS: awk negative field access
======================
echo -ne '' >input
echo -ne 'anything' | awk -v i=1 "BEGIN {print \"str\" ++i}"
PASS: awk do not allow "str"++
======================
echo -ne '' >input
echo -ne 'foo--bar' | awk -F '-*' '{print $1 "-" $2 "=" $3 "*" $4}'
PASS: awk FS regex which can match empty string
======================
echo -ne '' >input
echo -ne 'a=====123=' | awk -F '=+' '{print $NF}'
PASS: awk $NF is empty
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { exit 42 } END { exit }'; echo $?
PASS: awk exit N propagates through END's exit
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { print "STDERR %s" >"/dev/stderr" }' 2>&1
PASS: awk print + redirect
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { "echo HELLO" | getline; print }'
PASS: awk "cmd" | getline
======================
echo -ne '' >input
echo -ne '' | awk 'BEGIN { printf "%%\n" }'
PASS: awk printf %% prints one %
PASS: basename-does-not-remove-identical-extension
PASS: basename-works
======================
echo -ne '' >input
echo -ne '1 /* comment */ + 2' | bc
PASS: bc comment
======================
echo -ne '' >input
echo -ne '1 /*/ + 2 */ + 3' | bc
PASS: bc /*/ is not a closed comment
======================
echo -ne '' >input
echo -ne '1 /* " */ + 2' | bc
PASS: bc comment with "
======================
echo -ne '' >input
echo -ne '"string/*";9' | bc
PASS: bc "string/*" is not a comment
======================
echo -ne '' >input
echo -ne '#foo' | bc
PASS: bc comment 3: unterminated #comment
======================
echo -ne '' >input
echo -ne '1 \\\n + 2' | bc
PASS: bc backslash 1
======================
echo -ne '' >input
echo -ne '"STR\n"' | bc
PASS: bc string 1
======================
echo -ne 'read();halt' >input
echo -ne '4' | bc input
PASS: bc read() 4<EOF>
======================
echo -ne 'read()^2;halt' >input
echo -ne '4\n' | bc input
PASS: bc read()^2
======================
echo -ne 'read()*read();halt' >input
echo -ne '4\n5' | bc input
PASS: bc read()*read()
======================
echo -ne '' >input
echo -ne 'if (0) 1 else 2; 9' | bc
PASS: bc if 0 else
======================
echo -ne '' >input
echo -ne 'if (1) 1 else 2; 9' | bc
PASS: bc if 1 else
======================
echo -ne '' >input
echo -ne 'if (1) if (1) 1 else 2 else 3; 9' | bc
PASS: bc if 1 if 1 else else
======================
echo -ne '' >input
echo -ne 'if (0) 1 else if (1) 2; 9' | bc
PASS: bc if 0 else if 1
======================
echo -ne '' >input
echo -ne 'i=2; for (;;) { 2; if(--i==0) break; 3; }; 9' | bc
PASS: bc for (;;)
======================
echo -ne '' >input
echo -ne 'i=0; for(;i<3;)++i; 9' | bc
PASS: bc for (;cond;)
======================
echo -ne '' >input
echo -ne 'i=1; for(;i<4;i++)i; 9' | bc
PASS: bc for (;cond;upd)
======================
echo -ne '' >input
echo -ne 'for(i=1;i<4;i++)i; 9' | bc
PASS: bc for (init;cond;upd)
======================
echo -ne '' >input
echo -ne 'for (;;) {2;break}; 9' | bc
PASS: bc for (;;) {break}
======================
echo -ne '' >input
echo -ne 'define w() {return}\nw();9' | bc
PASS: bc define {return}
======================
echo -ne '' >input
echo -ne 'define w() { auto z; return 8; }; w(); 9' | bc
PASS: bc define auto
======================
echo -ne '' >input
echo -ne 'define w(x) { auto x[]; return x; }; w(8); 9' | bc
PASS: bc define auto array same name
======================
echo -ne '' >input
echo -ne 'define w()\n{ auto z; return 8; }\nw()\n9' | bc
PASS: bc define with body on next line
======================
echo -ne '' >input
echo -ne 'define void w() {print "void"}\nw()\n9' | bc
PASS: bc void function
======================
echo -ne '' >input
echo -ne 'define void() {print "void"}\nvoid()\n9' | bc
PASS: bc function named 'void'
======================
echo -ne '' >input
echo -ne 'void=6\nvoid\n9' | bc
PASS: bc variable named 'void'
======================
echo -ne '' >input
echo -ne 'if(0)\n3\n9' | bc
PASS: bc if(cond)<NL>
======================
echo -ne '' >input
echo -ne 'if(0)3 else\n4\n9' | bc
PASS: bc if(cond) stmt else<NL>
======================
echo -ne '' >input
echo -ne 'i=9;while(--i)\ni\n9' | bc
PASS: bc while(cond)<NL>
======================
echo -ne '' >input
echo -ne 'ifz=1;ifz\n++ifz;ifz++\nifz' | bc
PASS: bc ifz does not match if keyword
======================
echo -ne '' >input
echo -ne 'e(0)-2' | bc -l
PASS: bc -l 'e(0)-2'
======================
echo -ne '' >input
echo -ne '(!a&&b)' | bc
PASS: bc (!a&&b)
======================
echo -ne '' >input
echo -ne 'print ""' | bc
PASS: bc print ""
======================
echo -ne '' >input
echo -ne 'print 1,2,3' | bc
PASS: bc print 1,2,3
======================
echo -ne '' >input
echo -ne 'length(0); length(100); length(0.01); length(0.00120); length(0.012-0.012);' | bc
PASS: bc length
======================
echo -ne '' >input
echo -ne '{ print 1 }' | bc
PASS: bc { print 1 }
======================
echo -ne '' >input
echo -ne '-10 < -9' | bc
PASS: bc comparison 1
======================
echo -ne '' >input
echo -ne 'if(1) {
11
while(1) {
21
while(1) {
31
break
32
}
22
break
23
}
12
} else {
88
}
99
' | bc
PASS: bc nested loops and breaks
======================
echo -ne '' >input
echo -ne 'i=2
while(i--) {
11
if(i) {
21
continue
22
} else {
31
continue
32
}
12
}
99
' | bc
PASS: bc continue in if
======================
echo -ne '' >input
echo -ne 'for(i=1; i<3; i++) {
    i
    if(i==2) continue
    77
}
99
' | bc
PASS: bc continue in for
======================
echo -ne '' >input
echo -ne 'a=ZZ;a;ibase=36;a=ZZ;a;ibase=Z;a=ZZ;a' | bc
PASS: bc ibase
======================
echo -ne '' >input
echo -ne '
for (b = 2; b <= 16; ++b) {
if (b == 10) continue
obase = 10
print "ibase = A; ibase = ", b, "\n"
obase = b
for (i = 0; i <= 65536; ++i) {
i
print "0.", i, "\n"
print "1.", i, "\n"
print i, ".", i, "\n"
}
}' | bc 2>&1 | bc 2>&1 | md5sum 2>&1
PASS: bc parsing of numbers
======================
echo -ne '' >input
echo -ne '
for (b = 2; b <= 101; ++b) {
if (b == 10) continue
s = b * b
print "obase = ", b, "\n"
for (i = 0; i <= s; ++i) {
i
print "0.", i, "\n"
print "1.", i, "\n"
print i, ".", i, "\n"
}
2189432174861923048671023498128347619023487610234689172304.192748960128745108927461089237469018723460
}' | bc 2>&1 | bc 2>&1 | md5sum 2>&1
PASS: bc printing of numbers
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_add.bc 2>&1; echo E:$? >&2; } | diff -u - bc_add_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_add.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_arctangent.bc 2>&1; echo E:$? >&2; } | diff -u - bc_arctangent_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_arctangent.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_array.bc 2>&1; echo E:$? >&2; } | diff -u - bc_array_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_array.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_arrays.bc 2>&1; echo E:$? >&2; } | diff -u - bc_arrays_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_arrays.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_bessel.bc 2>&1; echo E:$? >&2; } | diff -u - bc_bessel_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_bessel.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_boolean.bc 2>&1; echo E:$? >&2; } | diff -u - bc_boolean_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_boolean.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_cosine.bc 2>&1; echo E:$? >&2; } | diff -u - bc_cosine_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_cosine.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_decimal.bc 2>&1; echo E:$? >&2; } | diff -u - bc_decimal_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_decimal.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_divide.bc 2>&1; echo E:$? >&2; } | diff -u - bc_divide_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_divide.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_exponent.bc 2>&1; echo E:$? >&2; } | diff -u - bc_exponent_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_exponent.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_log.bc 2>&1; echo E:$? >&2; } | diff -u - bc_log_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_log.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_misc.bc 2>&1; echo E:$? >&2; } | diff -u - bc_misc_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_misc.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_misc1.bc 2>&1; echo E:$? >&2; } | diff -u - bc_misc1_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_misc1.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_misc2.bc 2>&1; echo E:$? >&2; } | diff -u - bc_misc2_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_misc2.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_modulus.bc 2>&1; echo E:$? >&2; } | diff -u - bc_modulus_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_modulus.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_multiply.bc 2>&1; echo E:$? >&2; } | diff -u - bc_multiply_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_multiply.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_numbers1.bc 2>&1; echo E:$? >&2; } | diff -u - bc_numbers1_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_numbers1.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_numbers2.bc 2>&1; echo E:$? >&2; } | diff -u - bc_numbers2_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_numbers2.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_pi.bc 2>&1; echo E:$? >&2; } | diff -u - bc_pi_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_pi.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_power.bc 2>&1; echo E:$? >&2; } | diff -u - bc_power_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_power.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_references.bc 2>&1; echo E:$? >&2; } | diff -u - bc_references_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_references.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_sine.bc 2>&1; echo E:$? >&2; } | diff -u - bc_sine_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_sine.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_sqrt.bc 2>&1; echo E:$? >&2; } | diff -u - bc_sqrt_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_sqrt.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_strings.bc 2>&1; echo E:$? >&2; } | diff -u - bc_strings_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_strings.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_subtract.bc 2>&1; echo E:$? >&2; } | diff -u - bc_subtract_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_subtract.bc
======================
echo -ne '' >input
echo -ne '' | { { bc -lq bc_vars.bc 2>&1; echo E:$? >&2; } | diff -u - bc_vars_results.txt; echo E:$?; } 2>&1
PASS: bc -lq bc_vars.bc
PASS: bunzip2-reads-from-standard-input
PASS: bunzip2-removes-compressed-file
PASS: bunzip2: doesnt exist
PASS: bunzip2: unknown suffix
PASS: bunzip2: already exists
PASS: bunzip2: stream unpack
PASS: bunzip2: delete src
PASS: bunzip2: test_bz2 file
PASS: bunzip2: pbzip_4m_zeros file
PASS: bunzip2: bz2_issue_11.bz2 corrupted example
PASS: bunzip2: bz2_issue_12.bz2 corrupted example
PASS: bzcat-does-not-remove-compressed-file
PASS: zcat: dont delete gz src
PASS: zcat: dont delete bz2 src
PASS: zcat: dont delete Z src
======================
echo -ne '\x42\x5a\x68\x39\x31\x41\x59\x26\x53\x59\x63\x3e\xd6\xe2\x00\x00\x00\xc1\x00\x00\x10\x20\x00\x20\x00\x21\x00\x82\xb1\x77\x24\x53\x85\x09\x06\x33\xed\x6e\x20' >input
echo -ne '' | bzcat input input; echo $?
PASS: bzcat can print many files
======================
echo -ne '\x42\x5a\x68\x39\x17\x72\x45\x38\x50\x90\x00\x00\x00\x00' >input
echo -ne '' | bzcat input input; echo $?
PASS: bzcat can handle compressed zero-length bzip2 files
======================
echo -ne '\x1f\x9d\x90\x61\x14\x00' >input
echo -ne '' | zcat input input; echo $?
PASS: zcat can print many files
======================
echo -ne '\x1f\x9d\x90\x00' >input
echo -ne '' | zcat input input; echo $?
PASS: zcat can handle compressed zero-length (.Z) files
======================
echo -ne '' >input
echo -ne '' | cal 1 2000
PASS: cal 2000
PASS: cat-prints-a-file
PASS: cat-prints-a-file-and-standard-input
======================
echo -ne '' >input
echo -ne 'foo\n' | cat -e
PASS: cat -e
======================
echo -ne '' >input
echo -ne 'foo\n' | cat -v
PASS: cat -v
======================
echo -ne '' >input
echo -ne 'line 1\n\nline 3\n' | cat -n
PASS: cat -n
======================
echo -ne '' >input
echo -ne 'line 1\n\nline 3\n' | cat -b
PASS: cat -b
PASS: cmp-detects-difference
======================
echo -ne '456\nabc\n' >input
echo -ne '123\ndef\n' | comm input -
PASS: comm test 1
======================
echo -ne '456\nabc\n' >input
echo -ne '123\ndef\n' | comm - input
PASS: comm test 2
======================
echo -ne 'abc\nxyz\n' >input
echo -ne 'def\n' | comm input -
PASS: comm test 3
======================
echo -ne 'abc\nxyz\n' >input
echo -ne 'def\n' | comm - input
PASS: comm test 4
======================
echo -ne '123\nabc\n' >input
echo -ne 'def\n' | comm input -
PASS: comm test 5
======================
echo -ne '123\nabc\n' >input
echo -ne 'def\n' | comm - input
PASS: comm test 6
======================
echo -ne 'abc' >input
echo -ne 'def' | comm input -
PASS: comm unterminated line 1
======================
echo -ne 'abc' >input
echo -ne 'def' | comm - input
PASS: comm unterminated line 2
PASS: cp-RHL-does_not_preserve-links
PASS: cp-a-files-to-dir
PASS: cp-a-preserves-links
PASS: cp-copies-empty-file
PASS: cp-copies-large-file
PASS: cp-copies-small-file
PASS: cp-d-files-to-dir
PASS: cp-dev-file
PASS: cp-dir-create-dir
PASS: cp-dir-existing-dir
PASS: cp-does-not-copy-unreadable-file
PASS: cp-files-to-dir
PASS: cp-follows-links
PASS: cp-parents
PASS: cp-preserves-hard-links
PASS: cp-preserves-links
PASS: cp-preserves-source-file
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file         && test   -f file             || echo BAD: file
test ! -L file_symlink && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir          && test ! -e dir              || echo BAD: dir
test ! -L dir_symlink  && test ! -e dir_symlink      || echo BAD: dir_symlink

PASS: cp
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -d * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file         && test   -f file             || echo BAD: file
test   -L file_symlink && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir          && test ! -e dir              || echo BAD: dir
test   -L dir_symlink  && test ! -e dir_symlink      || echo BAD: dir_symlink

PASS: cp -d
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -P * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file         && test   -f file             || echo BAD: file
test   -L file_symlink && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir          && test ! -e dir              || echo BAD: dir
test   -L dir_symlink  && test ! -e dir_symlink      || echo BAD: dir_symlink

PASS: cp -P
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -L * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file         && test   -f file             || echo BAD: file
test ! -L file_symlink && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir          && test ! -e dir              || echo BAD: dir
test ! -L dir_symlink  && test ! -e dir_symlink      || echo BAD: dir_symlink

PASS: cp -L
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -H * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file         && test   -f file             || echo BAD: file
test ! -L file_symlink && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir          && test ! -e dir              || echo BAD: dir
test ! -L dir_symlink  && test ! -e dir_symlink      || echo BAD: dir_symlink

PASS: cp -H
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -R * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file             && test   -f file             || echo BAD: file
test   -L file_symlink     && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir              && test   -d dir              || echo BAD: dir
test   -L dir_symlink      && test   -d dir_symlink      || echo BAD: dir_symlink
test ! -L dir/file         && test   -f dir/file         || echo BAD: dir/file
test   -L dir/file_symlink && test   -f dir/file_symlink || echo BAD: dir/file_symlink

PASS: cp -R
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -Rd * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file             && test   -f file             || echo BAD: file
test   -L file_symlink     && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir              && test   -d dir              || echo BAD: dir
test   -L dir_symlink      && test   -d dir_symlink      || echo BAD: dir_symlink
test ! -L dir/file         && test   -f dir/file         || echo BAD: dir/file
test   -L dir/file_symlink && test   -f dir/file_symlink || echo BAD: dir/file_symlink

PASS: cp -Rd
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -RP * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file             && test   -f file             || echo BAD: file
test   -L file_symlink     && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir              && test   -d dir              || echo BAD: dir
test   -L dir_symlink      && test   -d dir_symlink      || echo BAD: dir_symlink
test ! -L dir/file         && test   -f dir/file         || echo BAD: dir/file
test   -L dir/file_symlink && test   -f dir/file_symlink || echo BAD: dir/file_symlink

PASS: cp -RP
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -RL * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file             && test   -f file             || echo BAD: file
test ! -L file_symlink     && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir              && test   -d dir              || echo BAD: dir
test ! -L dir_symlink      && test   -d dir_symlink      || echo BAD: dir_symlink
test ! -L dir/file         && test   -f dir/file         || echo BAD: dir/file
test ! -L dir/file_symlink && test   -f dir/file_symlink || echo BAD: dir/file_symlink

PASS: cp -RL
======================
echo -ne '' >input
echo -ne '' | \
cd cp.testdir || exit 1; cp -RHL * ../cp.testdir2 2>&1; echo $?; cd ../cp.testdir2 || exit 1
test ! -L file             && test   -f file             || echo BAD: file
test ! -L file_symlink     && test   -f file_symlink     || echo BAD: file_symlink
test ! -L dir              && test   -d dir              || echo BAD: dir
test ! -L dir_symlink      && test   -d dir_symlink      || echo BAD: dir_symlink
test ! -L dir/file         && test   -f dir/file         || echo BAD: dir/file
test ! -L dir/file_symlink && test   -f dir/file_symlink || echo BAD: dir/file_symlink

PASS: cp -RHL
======================
echo -ne '' >input
echo -ne '' | /bin/echo -ne '\x42\x5a\x68\x39\x31\x41\x59\x26\x53\x59\x64\x1e\x91\x8c\x00\x00\x48\x7f\x80\x4c\x48\x08\x00\x28\x01\xff\xe0\x3f\x24\x14\x00\x0e\x20\xdc\x60\x20\x00\x92\x11\xea\xa0\x1a\x00\x00\x00\x03\x20\x8a\x93\xd4\x9a\x68\x1a\x0d\x1e\x91\xa1\xa0\x06\x98\xe3\x5c\x2f\xd9\x26\xa1\x25\x24\x20\xed\x47\xc7\x21\x40\x2b\x6e\xf2\xe6\xfe\x98\x13\x68\xa8\xbd\x82\xb2\x4f\x26\x02\x24\x16\x5b\x22\x16\x72\x74\x15\xcd\xc1\xa6\x9e\xa6\x5e\x6c\x16\x37\x35\x01\x99\xc4\x81\x21\x29\x28\x4b\x69\x51\xa9\x3c\x1a\x9b\x0a\xe1\xe4\xb4\xaf\x85\x73\xba\x23\x10\x59\xe8\xb3\xe1\xa1\x63\x05\x8c\x4f\xc5\xdc\x91\x4e\x14\x24\x19\x07\xa4\x63\x00' | bzcat | cpio -i 2>&1; echo $?;
ls -ln cpio.testdir | sed 's/  */ /g' | cut -d' ' -f 1-5,9- | grep -v '^total '
PASS: cpio extracts zero-sized hardlinks
======================
echo -ne '' >input
echo -ne '' | find cpio.testdir | cpio -H newc --create | (cd cpio.testdir2 && cpio -i 2>&1); echo $?;
ls -ln cpio.testdir2/cpio.testdir | sed 's/  */ /g' | cut -d' ' -f 1-5,9- | grep -v '^total '
PASS: cpio extracts zero-sized hardlinks 2
======================
echo -ne '' >input
echo -ne '' | echo /usr/bin | cpio -dp cpio.testdir 2>&1; echo $?;
ls cpio.testdir
PASS: cpio -p with absolute paths
======================
echo -ne '' >input
echo -ne '' | cd cpio.testdir && { echo file; echo link; } | cpio -ovHnewc >pack.cpio && rm ???? && cpio -idmvu <pack.cpio 2>/dev/null;
 stat -c '%a %n' file
PASS: cpio restores suid/sgid bits
======================
echo -ne '' >input
echo -ne '' | /bin/echo -ne '\x42\x5a\x68\x39\x31\x41\x59\x26\x53\x59\x64\x1e\x91\x8c\x00\x00\x48\x7f\x80\x4c\x48\x08\x00\x28\x01\xff\xe0\x3f\x24\x14\x00\x0e\x20\xdc\x60\x20\x00\x92\x11\xea\xa0\x1a\x00\x00\x00\x03\x20\x8a\x93\xd4\x9a\x68\x1a\x0d\x1e\x91\xa1\xa0\x06\x98\xe3\x5c\x2f\xd9\x26\xa1\x25\x24\x20\xed\x47\xc7\x21\x40\x2b\x6e\xf2\xe6\xfe\x98\x13\x68\xa8\xbd\x82\xb2\x4f\x26\x02\x24\x16\x5b\x22\x16\x72\x74\x15\xcd\xc1\xa6\x9e\xa6\x5e\x6c\x16\x37\x35\x01\x99\xc4\x81\x21\x29\x28\x4b\x69\x51\xa9\x3c\x1a\x9b\x0a\xe1\xe4\xb4\xaf\x85\x73\xba\x23\x10\x59\xe8\xb3\xe1\xa1\x63\x05\x8c\x4f\xc5\xdc\x91\x4e\x14\x24\x19\x07\xa4\x63\x00' | bzcat | cpio -id 2>&1; echo $?
PASS: cpio extracts in existing directory
======================
echo -ne '' >input
echo -ne '' | echo /usr/share/busybox/testsuite/cpio.tests | cpio -o -H newc | cpio -tv 2>&1 | head -n1 | awk ' { print $2 } '; echo $?
PASS: cpio uses by default uid/gid
======================
echo -ne '' >input
echo -ne '' | echo /usr/share/busybox/testsuite/cpio.tests | cpio -o -H newc -R 1234:5678 | cpio -tv 2>&1 | head -n1 | awk ' { print $2 } '; echo $?
PASS: cpio -R with create
======================
echo -ne '' >input
echo -ne '' | echo /usr/share/busybox/testsuite/cpio.tests | cpio -o -H newc | cpio -tv -R 8765:4321 2>&1 | head -n1 | awk ' { print $2 } '; echo $?
PASS: cpio -R with extract
======================
echo -ne '' >input
echo -ne '' | cryptpw -m des QWErty '123456789012345678901234567890'
PASS: cryptpw des 12
======================
echo -ne '' >input
echo -ne '' | cryptpw -m des QWErty 55
PASS: cryptpw des 55
======================
echo -ne '' >input
echo -ne '' | cryptpw -m des QWErty zz
PASS: cryptpw des zz
SKIPPED: cryptpw sha256
SKIPPED: cryptpw sha256 rounds=99999
SKIPPED: cryptpw sha512
SKIPPED: cryptpw sha512 rounds=99999
PASS: cut-cuts-a-character
PASS: cut-cuts-a-closed-range
PASS: cut-cuts-a-field
PASS: cut-cuts-an-open-range
PASS: cut-cuts-an-unclosed-range
======================
echo -ne 'the quick brown fox\n' >input
echo -ne 'jumps over the lazy dog\n' | cut -d' ' -f2 - input
PASS: cut '-' (stdin) and multi file handling
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -b 3,3,3 input
PASS: cut -b a,a,a
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -b 1-3,2-5,7-9,9-10 input
PASS: cut -b overlaps
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -b 3-8,4-6 input
PASS: -b encapsulated
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -b 8-3 abc.txt 2>/dev/null || echo err
PASS: cut high-low error
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -c 4-10 input
PASS: cut -c a-b
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -c 41- input
PASS: cut -c a-
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -c -39 input
PASS: cut -c -b
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -c 40 input
PASS: cut -c a
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -c 3,5-7,10 input
PASS: cut -c a,b-c,d
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -d ':' -f 5- input
PASS: cut -f a-
======================
echo -ne 'one:two:three:four:five:six:seven
alpha:beta:gamma:delta:epsilon:zeta:eta:theta:iota:kappa:lambda:mu
the quick brown fox jumps over the lazy dog
' >input
echo -ne '' | cut -d ' ' -f 3 input
PASS: cut show whole line with no delim
======================
echo -ne '' >input
echo -ne '' | echo 'ref_categorie=test' | cut -c 1-15 
PASS: cut with echo, -c (a-b)
======================
echo -ne '' >input
echo -ne '' | echo 'ref_categorie=test' | cut -c 14
PASS: cut with echo, -c (a)
======================
echo -ne 'abcdefghijklmnopqrstuvwxyz' >input
echo -ne '' | cut -c 4,5,20 input
PASS: cut with -c (a,b,c)
======================
echo -ne 'abcdefghijklmnopqrstuvwxyz' >input
echo -ne '' | cut -b 4,5,20 input
PASS: cut with -b (a,b,c)
======================
echo -ne '406378:Sales:Itorre:Jan
031762:Marketing:Nasium:Jim
636496:Research:Ancholie:Mel
396082:Sales:Jucacion:Ed
' >input
echo -ne '' | cut -d: -f3 -s input
PASS: cut with -d -f(:) -s
======================
echo -ne '406378:Sales:Itorre:Jan
031762:Marketing:Nasium:Jim
636496:Research:Ancholie:Mel
396082:Sales:Jucacion:Ed
' >input
echo -ne '' | cut -d' ' -f3 -s input && echo yes
PASS: cut with -d -f( ) -s
======================
echo -ne '406378:Sales:Itorre:Jan
031762:Marketing:Nasium:Jim
636496:Research:Ancholie:Mel
396082:Sales:Jucacion:Ed
' >input
echo -ne '' | cut -da -f3 -s input
PASS: cut with -d -f(a) -s
======================
echo -ne '406378:Sales:Itorre:Jan
031762:Marketing:Nasium:Jim
636496:Research:Ancholie:Mel
396082:Sales:Jucacion:Ed
' >input
echo -ne '' | cut -da -f3 -s -n input
PASS: cut with -d -f(a) -s -n
======================
echo -ne '' >input
echo -ne 'Bother, said Pooh. It's your husband, and he has a gun.
Cheerios are donut seeds.
Talk is cheap because supply exceeds demand.
Weather forecast for tonight : dark.
Apple: you can buy better, but you can't pay more.
Subcalifragilisticexpialidocious.
Auntie Em: Hate you, hate Kansas. Took the dog. Dorothy.' | cut -DF 2,7,5
PASS: cut -DF
======================
echo -ne '' >input
echo -ne 'a::b\n' | cut -d ':' -f 1-3
PASS: cut empty field
======================
echo -ne '' >input
echo -ne 'a::b::c:d\n' | cut -d ':' -f 3-5
PASS: cut empty field 2
PASS: date-@-works
PASS: date-R-works
PASS: date-format-works
PASS: date-timezone
PASS: date-u-works
PASS: date-works
PASS: date-works-1
PASS: dd-accepts-if
PASS: dd-accepts-of
PASS: dd-copies-from-standard-input-to-standard-output
PASS: dd-count-bytes
PASS: dd-prints-count-to-standard-error
PASS: dd-reports-write-errors
======================
echo -ne 'qwe\nasd\nzxc\n' >input
echo -ne 'asd\n' | diff -u - input | sed 's/.*//'
PASS: diff of stdin
======================
echo -ne 'qwe\nasd\nzxc' >input
echo -ne 'asd\n' | diff -u - input | sed 's/.*//'
PASS: diff of stdin, no newline in the file
======================
echo -ne '' >input
echo -ne 'stdin' | diff - -; echo $?; wc -c
PASS: diff of stdin, twice
======================
echo -ne '' >input
echo -ne 'a\n' | diff -u - input | sed 's/.*//'
PASS: diff of empty file against stdin
======================
echo -ne 'a\n' >input
echo -ne '' | diff -u - input | sed 's/.*//'
PASS: diff of empty file against nonempty one
======================
echo -ne 'abc' >input
echo -ne 'abc ' | diff -ub - input; echo $?
PASS: diff -b treats EOF as whitespace
======================
echo -ne 'a \t c\n' >input
echo -ne 'a\t \tc\n' | diff -ub - input; echo $?
PASS: diff -b treats all spaces as equal
======================
echo -ne 'a\n' >input
echo -ne '\na\n\n' | diff -uB - input; echo $?
PASS: diff -B ignores changes whose lines are all blank
======================
echo -ne 'a\n' >input
echo -ne '\nb\n\n' | diff -uB - input | sed 's/.*//'
PASS: diff -B does not ignore changes whose lines are not all blank
======================
echo -ne '\n1\n' >input
echo -ne '1\n' | diff -qB - input; echo $?
PASS: diff -B ignores blank single line change
======================
echo -ne '0\n' >input
echo -ne '1\n' | diff -qB - input; echo $?
PASS: diff -B does not ignore non-blank single line change
======================
echo -ne 'abc\na  c\ndef\n' >input
echo -ne 'a c\n' | diff -ub - input | sed 's/.*//'
PASS: diff always takes context from old file
======================
echo -ne '' >input
echo -ne '' | diff -ur diff1 diff2/subdir | sed 's/.*//'
PASS: diff diff1 diff2/subdir
======================
echo -ne '' >input
echo -ne '' | diff -ur diff1 diff2/subdir/- | sed 's/.*//'
PASS: diff dir dir2/file/-
======================
echo -ne '' >input
echo -ne '' | diff -ur diff1 diff2/subdir | sed 's/.*//'
PASS: diff of dir and fifo
======================
echo -ne '' >input
echo -ne '' | diff -ur diff1 diff2/subdir | sed 's/.*//'
PASS: diff of file and fifo
======================
echo -ne '' >input
echo -ne '' | diff -urN diff1 diff2/subdir | sed 's/.*//'
PASS: diff -rN does not read non-regular files
======================
echo -ne '' >input
echo -ne '' | diff -ur diff1 diff2/ | sed 's/.*//'; diff -ur .///diff1 diff2//// | sed 's/.*//'
PASS: diff diff1 diff2/
PASS: dirname-handles-absolute-path
PASS: dirname-handles-empty-path
PASS: dirname-handles-multiple-slashes
PASS: dirname-handles-relative-path
PASS: dirname-handles-root
PASS: dirname-handles-single-component
PASS: dirname-works
PASS: du-h-works
PASS: du-k-works
PASS: du-l-works
PASS: du-m-works
PASS: du-s-works
PASS: du-works
PASS: echo-does-not-print-newline
PASS: echo-prints-argument
PASS: echo-prints-arguments
PASS: echo-prints-dash
PASS: echo-prints-newline
PASS: echo-prints-non-opts
PASS: echo-prints-slash-zero
PASS: echo-prints-slash_00041
PASS: echo-prints-slash_0041
PASS: echo-prints-slash_041
PASS: echo-prints-slash_41
======================
echo -ne '' >input
echo -ne '\t12345678\t12345678\n' | expand
PASS: expand
======================
echo -ne '' >input
echo -ne 'Δ\t12345ΔΔΔ\t12345678\n' | expand
PASS: expand with unicode characher 0x394
PASS: expr-big
PASS: expr-works
======================
echo -ne '' >input
echo -ne '' | factor '  0'
PASS: factor '  0'
======================
echo -ne '' >input
echo -ne '' | factor +1
PASS: factor +1
======================
echo -ne '' >input
echo -ne '' | factor ' +2'
PASS: factor ' +2'
======================
echo -ne '' >input
echo -ne '' | factor 1024
PASS: factor 1024
======================
echo -ne '' >input
echo -ne '' | factor 2305843009213693951
PASS: factor 2^61-1
======================
echo -ne '' >input
echo -ne '' | factor 4611686018427387903
PASS: factor 2^62-1
======================
echo -ne '' >input
echo -ne '' | factor 18446744073709551615
PASS: factor 2^64-1
======================
echo -ne '' >input
echo -ne '' | factor $((2*3*5*7*11*13*17*19*23*29*31*37*41*43*47))
PASS: factor $((2*3*5*7*11*13*17*19*23*29*31*37*41*43*47))
======================
echo -ne '' >input
echo -ne '' | factor 18446743988964486098
PASS: factor 2 * 3037000493 * 3037000493
======================
echo -ne '' >input
echo -ne '' | factor 18446743902517389507
PASS: factor 3 * 2479700513 * 2479700513
======================
echo -ne '' >input
echo -ne '' | factor 6144867742934288163
PASS: factor 3 * 37831 * 37831 * 37831 * 37831
======================
echo -ne '' >input
echo -ne '' | factor 1996249827549539523
PASS: factor 3 * 13^16
======================
echo -ne '' >input
echo -ne '' | factor 665416609183179841
PASS: factor 13^16
PASS: false-is-silent
PASS: false-returns-failure
PASS: find-supports-minus-xdev
======================
echo -ne '' >input
echo -ne '' | cd find.tempdir && find -type f 2>&1
PASS: find -type f
======================
echo -ne '' >input
echo -ne '' | cd find.tempdir && find testfile -exec true {} \; 2>&1; echo $?
PASS: find -exec exitcode 1
======================
echo -ne '' >input
echo -ne '' | cd find.tempdir && find testfile -exec true {} + 2>&1; echo $?
PASS: find -exec exitcode 2
======================
echo -ne '' >input
echo -ne '' | cd find.tempdir && find testfile -exec false {} \; 2>&1; echo $?
PASS: find -exec exitcode 3
======================
echo -ne '' >input
echo -ne '' | cd find.tempdir && find testfile -exec false {} + 2>&1; echo $?
PASS: find -exec exitcode 4
======================
echo -ne '' >input
echo -ne '' | find / -maxdepth 0 -name /
PASS: find / -maxdepth 0 -name /
======================
echo -ne '' >input
echo -ne '' | find // -maxdepth 0 -name /
PASS: find // -maxdepth 0 -name /
======================
echo -ne '' >input
echo -ne '' | find / -maxdepth 0 -name //
PASS: find / -maxdepth 0 -name //
======================
echo -ne '' >input
echo -ne '' | find // -maxdepth 0 -name //
PASS: find // -maxdepth 0 -name //
======================
echo -ne '' >input
echo -ne '' | find ./// -name .
PASS: find ./// -name .
======================
echo -ne '' >input
echo -ne '' | find ./// -name .///
PASS: find ./// -name .///
======================
echo -ne '' >input
echo -ne '123456\tasdf' | fold -w 7 -s
PASS: fold -s
======================
echo -ne '' >input
echo -ne 'qq w eee r tttt y' | fold -w1
PASS: fold -w1
======================
echo -ne '' >input
echo -ne 'The NUL is here:>\0< and another one is here:>\0< - they must be preserved
' | fold -sw22
PASS: fold with NULs
======================
echo -ne '' >input
echo -ne 'The Andromeda Galaxy (pronounced /ænˈdrɒmədə/, also known as Messier 31, M31, or NGC224; often referred to as the Great Andromeda Nebula in older texts) is a spiral galaxy approximately 2,500,000 light-years (1.58×10^11 AU) away in the constellation Andromeda. It is the nearest spiral galaxy to our own, the Milky Way.
Галактика або Туманність Андромеди (також відома як M31 за каталогом Мессьє та NGC224 за Новим загальним каталогом)  спіральна галактика, що знаходиться на відстані приблизно у 2,5 мільйони світлових років від нашої планети у сузір'ї Андромеди. На початку ХХІ ст. в центрі галактики виявлено чорну дірку.' | fold -sw66
PASS: fold -sw66 with unicode input
======================
echo -ne '' >input
echo -ne '' | grep nonexistent 2> /dev/null ; echo $?
PASS: grep (exit with error)
======================
echo -ne '' >input
echo -ne '' | grep grep '/usr/share/busybox/testsuite/grep.tests' > /dev/null 2>&1 ; echo $?
PASS: grep (exit success)
======================
echo -ne '' >input
echo -ne 'one\ntwo\nthree\nthree\nthree\n' | grep two
PASS: grep (default to stdin)
======================
echo -ne '' >input
echo -ne 'one\ntwo\nthree\nthree\nthree\n' | grep two -
PASS: grep - (specify stdin)
======================
echo -ne 'one\ntwo\nthree\nthree\nthree\n' >input
echo -ne '' | grep two input
PASS: grep input (specify file)
======================
echo -ne 'bug' >input
echo -ne '' | grep bug input
PASS: grep (no newline at EOL)
======================
echo -ne 'one\ntwo\nthree\nthree\nthree\n' >input
echo -ne '' | grep two input empty 2>/dev/null
PASS: grep two files
======================
echo -ne 'one\ntwo\nthree\n' >input
echo -ne 'one\ntwo\ntoo\nthree\nthree\n' | grep two - input
PASS: grep - infile (specify stdin and file)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | grep two - nonexistent 2> /dev/null ; echo $?
PASS: grep - nofile (specify stdin and nonexisting file)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | grep -q nomatch - nonexistent 2> /dev/null ; echo $?
PASS: grep -q - nofile (specify stdin and nonexisting file, no match)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | grep -q two - nonexistent ; echo $?
PASS: grep -q - nofile (specify stdin and nonexisting file, match)
======================
echo -ne '' >input
echo -ne '' | grep -s nomatch nonexistent ; echo $?
PASS: grep -s nofile (nonexisting file, no match)
======================
echo -ne '' >input
echo -ne 'nomatch\ndomatch\nend\n' | grep -s domatch nonexistent - ; echo $?
PASS: grep -s nofile - (stdin and nonexisting file, match)
SKIPPED: grep handles NUL in files
SKIPPED: grep handles NUL on stdin
SKIPPED: grep matches NUL
======================
echo -ne 'one\ntwo\n' >input
echo -ne '' | grep -e one -e two input ; echo $?
PASS: grep handles multiple regexps
======================
echo -ne 'one\ntwo\n' >input
echo -ne '' | grep -F -e one -e two input ; echo $?
PASS: grep -F handles multiple expessions
======================
echo -ne 'FOO\n' >input
echo -ne '' | grep -F -i foo input ; echo $?
PASS: grep -F handles -i
======================
echo -ne 'tw\ntwo\nthree\n' >input
echo -ne 'tw.\nthr\n' | grep -f - input ; echo $?
PASS: grep can read regexps from stdin
======================
echo -ne 'foo\n' >input
echo -ne '' | grep -x foo input ; echo $?
PASS: grep -x (full match)
======================
echo -ne 'foo bar\n' >input
echo -ne '' | grep -x foo input ; echo $?
PASS: grep -x (partial match 1)
======================
echo -ne 'bar foo\n' >input
echo -ne '' | grep -x foo input ; echo $?
PASS: grep -x (partial match 2)
======================
echo -ne 'foo\n' >input
echo -ne '' | grep -x -F foo input ; echo $?
PASS: grep -x -F (full match)
======================
echo -ne 'foo bar\n' >input
echo -ne '' | grep -x -F foo input ; echo $?
PASS: grep -x -F (partial match 1)
======================
echo -ne 'bar foo\n' >input
echo -ne '' | grep -x -F foo input ; echo $?
PASS: grep -x -F (partial match 2)
======================
echo -ne 'asd\n' >input
echo -ne '' | grep -L qwe input; echo $?
PASS: grep -L exitcode 0
======================
echo -ne 'qwe\n' >input
echo -ne 'asd\n' | grep -L qwe input -; echo $?
PASS: grep -L exitcode 0 #2
======================
echo -ne 'qwe\n' >input
echo -ne '' | grep -L qwe input; echo $?
PASS: grep -L exitcode 1
======================
echo -ne '' >input
echo -ne 'b\ar\nfoo\nbaz' | grep -E fo+
PASS: grep -E supports extended regexps
======================
echo -ne '' >input
echo -ne 'foo\nbar\n' | egrep foo
PASS: grep is also egrep
======================
echo -ne '' >input
echo -ne 'FOO\n' | egrep foo ; [ $? -ne 0 ] && echo yes
PASS: egrep is not case insensitive
======================
echo -ne '' >input
echo -ne '00:19:3E:00:AA:5E 00:1D:60:3D:3A:FB 00:22:43:49:FB:AA\n' | grep -E -o '([[:xdigit:]]{2}[:-]){5}[[:xdigit:]]{2}'
PASS: grep -E -o prints all matches
======================
echo -ne '' >input
echo -ne '/var/test\n' | grep -o "[^/]*$"
PASS: grep -o does not loop forever
======================
echo -ne '' >input
echo -ne 'test\n' | grep -o "" | head -n1
PASS: grep -o does not loop forever on zero-length match
======================
echo -ne '' >input
echo -ne 'test\n' | grep -f input
PASS: grep -f EMPTY_FILE
======================
echo -ne '' >input
echo -ne 'test\n' | grep -v -f input
PASS: grep -v -f EMPTY_FILE
======================
echo -ne '' >input
echo -ne 'test\n' | grep -vxf input
PASS: grep -vxf EMPTY_FILE
======================
echo -ne 'foop\n' >input
echo -ne '' | grep -Fw foo input
PASS: grep -Fw matches only words
======================
echo -ne 'foop foo\n' >input
echo -ne '' | grep -Fw foo input
PASS: grep -Fw doesn't stop on 1st mismatch
======================
echo -ne 'foop foo\n' >input
echo -ne '' | grep -w foo input
PASS: grep -w doesn't stop on 1st mismatch
======================
echo -ne 'strstr\n' >input
echo -ne '' | grep -w ^str input
PASS: grep -w ^str doesn't match str not at the beginning
======================
echo -ne 'anything\n' >input
echo -ne '' | grep -w ^ input
PASS: grep -w ^ doesn't hang
======================
echo -ne 'wordword\n' >input
echo -ne '' | grep -w word input
PASS: grep -w word doesn't match wordword
======================
echo -ne 'ww\n' >input
echo -ne '' | grep -F -w w input
PASS: grep -F -w w doesn't match ww
======================
echo -ne 'bword,word\nwordb,word\nbwordb,word\n' >input
echo -ne '' | grep -w word input
PASS: grep -w word match second word
======================
echo -ne '' >input
echo -ne '  aa bb cc\n' | grep -x -v -e '.*aa.*' -e 'bb.*'; echo $?
PASS: grep -x -v -e EXP1 -e EXP2 finds nothing if either EXP matches
======================
echo -ne '' >input
echo -ne 'foo\nbar\nbaz\n' | grep -Fv "$(printf "foo\nbar\n")"
PASS: grep PATTERN can be a newline-delimited list
======================
echo -ne '' >input
echo -ne 'foo\nbar\nbaz\n' | grep -Fv -e "$(printf "foo\nbar\n")"
PASS: grep -e PATTERN can be a newline-delimited list
======================
echo -ne '' >input
echo -ne '' | grep -r . grep.testdir/symfoo
PASS: grep -r on symlink to dir
======================
echo -ne '' >input
echo -ne '' | grep -r . grep.testdir
PASS: grep -r on dir/symlink to dir
PASS: gunzip-reads-from-standard-input
PASS: gunzip: doesnt exist
PASS: gunzip: unknown suffix
PASS: gunzip: already exists
PASS: gunzip: stream unpack
PASS: gunzip: delete src
PASS: gzip-accepts-multiple-files
PASS: gzip-accepts-single-minus
UNTESTED: gzip-compression-levels
PASS: gzip-removes-original-file
======================
echo -ne '' >input
echo -ne '' | head head.input
PASS: head (without args)
======================
echo -ne '' >input
echo -ne '' | head -n 2 head.input
PASS: head -n <positive number>
======================
echo -ne '' >input
echo -ne '' | head -n -9 head.input
PASS: head -n <negative number>
======================
echo -ne '' >input
echo -ne '\0\0\0\0' | hexdump -C
PASS: hexdump -C with four NULs
======================
echo -ne '' >input
echo -ne '\0\0\0\0\0\0\0\0\0\0\0' | hexdump -e '1/1 "%02x|"1/1 "%02x!\n"'
PASS: hexdump does not think last padded block matches any full block
======================
echo -ne '' >input
echo -ne '\0\0\0\0\0\0\0\0\0\0\0\0' | hexdump -e '1/1 "%02x|"1/1 "%02x!\n"'
PASS: hexdump thinks last full block can match
PASS: hostid-works
PASS: hostname-d-works
PASS: hostname-i-works
PASS: hostname-s-works
PASS: hostname-works
PASS: id-g-works
PASS: id-u-works
PASS: id-un-works
PASS: id-ur-works
PASS: ln-creates-hard-links
PASS: ln-creates-soft-links
PASS: ln-force-creates-hard-links
PASS: ln-force-creates-soft-links
PASS: ln-preserves-hard-links
PASS: ln-preserves-soft-links
PASS: ls-1-works
PASS: ls-h-works
PASS: ls-l-works
PASS: ls-s-works
======================
echo -ne '' >input
echo -ne '' | (cd ls.testdir && sh ../ls.mk_uni_tests) && ls -1 ls.testdir
PASS: ls unicode test with codepoints limited to 767
======================
echo -ne '' >input
echo -ne '' | touch ls.testdir/A ls.testdir/B; ln -s ls.testdir ls.link; ls ls.link; ls -1 ls.link/; ls -1 ls.link; rm -f ls.link
PASS: ls symlink_to_dir
PASS: md5sum-verifies-non-binary-file
PASS: md5sum
PASS: md5sum -c EMPTY
SKIPPED: mdev add /block/sda
SKIPPED: mdev deletes /block/sda
SKIPPED: mdev stops on first rule
SKIPPED: mdev does not stop on dash-rule
SKIPPED: mdev $ENVVAR=regex match
SKIPPED: mdev move/symlink rule '>bar/baz'
SKIPPED: mdev move/symlink rule '>bar/'
SKIPPED: mdev move rule '=bar/baz/fname'
SKIPPED: mdev regexp substring match + replace
SKIPPED: mdev command
SKIPPED: mdev move and command
SKIPPED: mdev #maj,min and no explicit uid
SKIPPED: move rule does not delete node with name == device_name
PASS: mkdir-makes-a-directory
PASS: mkdir-makes-parent-directories
SKIPPED: mount
PASS: mv-files-to-dir
PASS: mv-files-to-dir-2
PASS: mv-follows-links
PASS: mv-moves-empty-file
PASS: mv-moves-file
PASS: mv-moves-hardlinks
PASS: mv-moves-large-file
PASS: mv-moves-small-file
PASS: mv-moves-symlinks
PASS: mv-moves-unreadable-files
PASS: mv-preserves-hard-links
PASS: mv-preserves-links
PASS: mv-refuses-mv-dir-to-subdir
PASS: mv-removes-source-file
======================
echo -ne 'line 1\n\nline 3\n' >input
echo -ne '' | nl -b a input
PASS: nl numbers all lines
======================
echo -ne 'line 1\n\nline 3\n' >input
echo -ne '' | nl -b t input
PASS: nl numbers non-empty lines
======================
echo -ne 'line 1\n\nline 3\n' >input
echo -ne '' | nl -b n input
PASS: nl numbers no lines
======================
echo -ne '' >input
echo -ne 'HELLO' | od -b
PASS: od -b
======================
echo -ne '' >input
echo -ne '\x00\x00\x00\x00\x00\x00\x00\x00' | od -f
PASS: od -f
======================
echo -ne '' >input
echo -ne 'HELLO' | od -b --traditional
PASS: od -b --traditional
======================
echo -ne 'HELLO' >input
echo -ne '' | od -b --traditional input
PASS: od -b --traditional FILE
PASS: paste
PASS: paste-back-cuted-lines
PASS: paste-multi-stdin
PASS: paste-pairs
PASS: paste-separate
======================
echo -ne 'qwe
zxc
' >input
echo -ne '--- inputJan 01 01:01:01 2000
+++ inputJan 01 01:01:01 2000
@@ -1,2 +1,3 @@
 qwe
+asd
 zxc
' | patch 2>&1; echo $?; cat input
PASS: patch with old_file == new_file
======================
echo -ne 'qwe
zxc
' >input
echo -ne '--- input.doesnt_existJan 01 01:01:01 2000
+++ inputJan 01 01:01:01 2000
@@ -1,2 +1,3 @@
 qwe
+asd
 zxc
' | patch 2>&1; echo $?; cat input
PASS: patch with nonexistent old_file
======================
echo -ne 'qwe
asd
zxc
' >input
echo -ne '--- input.doesnt_existJan 01 01:01:01 2000
+++ inputJan 01 01:01:01 2000
@@ -1,2 +1,3 @@
 qwe
+asd
 zxc
' | patch -R 2>&1; echo $?; cat input
PASS: patch -R with nonexistent old_file
======================
echo -ne 'abc
def
123
' >input
echo -ne '--- input.oldJan 01 01:01:01 2000
+++ inputJan 01 01:01:01 2000
@@ -1,2 +1,3 @@
 abc
+def
 123
' | patch 2>&1; echo $?; cat input
PASS: patch detects already applied hunk
======================
echo -ne 'abc
123
456
' >input
echo -ne '--- input.oldJan 01 01:01:01 2000
+++ inputJan 01 01:01:01 2000
@@ -1,2 +1,3 @@
 abc
 123
+456
' | patch 2>&1; echo $?; cat input
PASS: patch detects already applied hunk at the EOF
======================
echo -ne 'abc
def
123
' >input
echo -ne '--- input
+++ input
@@ -1,2 +1,3 @@
 abc
+def
 123
' | patch -N 2>&1; echo $?; cat input
PASS: patch -N ignores already applied hunk
======================
echo -ne 'abc
123
' >input
echo -ne '--- foo.old
+++ foo
@@ -1,2 +1,3 @@
 abc
+def
 123
' | cat >a.patch; patch input a.patch 2>&1; echo $?; cat input; rm a.patch
PASS: patch FILE PATCH
======================
echo -ne '111
222
333
444
555
666
777
888
999
' >input
echo -ne '--- input
+++ input
@@ -1,6 +1,4 @@
-111
-222
-333
+111changed
 444
 555
 666
' | patch 2>&1; cat input
PASS: patch at the beginning
======================
echo -ne '' >input
echo -ne '--- /dev/null
+++ testfile
@@ -0,0 +1 @@
+qwerty
' | patch 2>&1; echo $?; cat testfile; rm testfile
PASS: patch creates new file
======================
echo -ne '' >input
echo -ne '--- bogus_dir///dir2///file
+++ bogus_dir///dir2///file
@@ -1,2 +1,3 @@
 qwe
+asd
 zxc
' | patch -p1 2>&1; echo $?
PASS: patch understands ...dir///dir...
======================
echo -ne 'foo







bar
' >input
echo -ne '--- a/input.orig
+++ b/input
@@ -5,5 +5,8 @@ foo
 
 
 
+1
+2
+3
 
 bar
-- 
2.9.2
' | patch -p1 2>&1; echo $?; cat input
PASS: patch internal buffering bug?
======================
echo -ne '' >input
echo -ne '' | pidof veryunlikelyoccuringbinaryname ; echo $?
PASS: pidof (exit with error)
======================
echo -ne '' >input
echo -ne '' | pidof pidof > /dev/null; echo $?
PASS: pidof (exit with success)
======================
echo -ne '' >input
echo -ne '' | pidof pidof.tests | grep -o -w 4798
PASS: pidof this
======================
echo -ne '' >input
echo -ne '' | pidof -o 1 init | grep -o -w 1
PASS: pidof -o init
======================
echo -ne '' >input
echo -ne '' | busybox printf '\c' foo
PASS: printf produces no further output 1
======================
echo -ne '' >input
echo -ne '' | busybox printf '%s\c' foo bar
PASS: printf produces no further output 2
======================
echo -ne '' >input
echo -ne '' | busybox printf '%s\n' foo '/root'
PASS: printf repeatedly uses pattern for each argv
======================
echo -ne '' >input
echo -ne '' | busybox printf '%b' 'a\tb' 'c\d\n' 2>&1; echo $?
PASS: printf understands %b escaped_string
======================
echo -ne '' >input
echo -ne '' | busybox printf '%d\n' '"x' "'y" "'zTAIL" 2>&1; echo $?
PASS: printf understands %d '"x' "'y" "'zTAIL"
======================
echo -ne '' >input
echo -ne '' | busybox printf '%s\n' '"x' "'y" "'zTAIL" 2>&1; echo $?
PASS: printf understands %s '"x' "'y" "'zTAIL"
======================
echo -ne '' >input
echo -ne '' | busybox printf '|%23.12f|\n' 5.25 2>&1; echo $?
PASS: printf understands %23.12f
======================
echo -ne '' >input
echo -ne '' | busybox printf '|%*.*f|\n' 23 12 5.25 2>&1; echo $?
PASS: printf understands %*.*f
======================
echo -ne '' >input
echo -ne '' | busybox printf '|%*f|\n' -23 5.25 2>&1; echo $?
PASS: printf understands %*f with negative width
======================
echo -ne '' >input
echo -ne '' | busybox printf '|%.*f|\n' -12 5.25 2>&1; echo $?
PASS: printf understands %.*f with negative precision
======================
echo -ne '' >input
echo -ne '' | busybox printf '|%*.*f|\n' -23 -12 5.25 2>&1; echo $?
PASS: printf understands %*.*f with negative width/precision
======================
echo -ne '' >input
echo -ne '' | busybox printf '%zd\n' -5 2>&1; echo $?
PASS: printf understands %zd
======================
echo -ne '' >input
echo -ne '' | busybox printf '%ld\n' -5 2>&1; echo $?
PASS: printf understands %ld
======================
echo -ne '' >input
echo -ne '' | busybox printf '%Ld\n' -5 2>&1; echo $?
PASS: printf understands %Ld
======================
echo -ne '' >input
echo -ne '' | busybox printf '%%\n' 2>&1; echo $?
PASS: printf understands %%
======================
echo -ne '' >input
echo -ne '' | busybox printf '%d\n' 3 +3 '   3' '   +3' 2>&1; echo $?
PASS: printf handles positive numbers for %d
======================
echo -ne '' >input
echo -ne '' | busybox printf '%i\n' 3 +3 '   3' '   +3' 2>&1; echo $?
PASS: printf handles positive numbers for %i
======================
echo -ne '' >input
echo -ne '' | busybox printf '%x\n' 42 +42 '   42' '   +42' 2>&1; echo $?
PASS: printf handles positive numbers for %x
======================
echo -ne '' >input
echo -ne '' | busybox printf '%0.3f\n' .42 +.42 '   .42' '   +.42' 2>&1; echo $?
PASS: printf handles positive numbers for %f
======================
echo -ne '' >input
echo -ne '' | busybox printf '%d\n' 1 - 2 bad 3 123bad 4 2>&1; echo $?
PASS: printf handles %d bad_input
======================
echo -ne '' >input
echo -ne '' | busybox printf '%' a b c 2>&1; echo $?
PASS: printf aborts on bare %
======================
echo -ne '' >input
echo -ne '' | busybox printf '%r' a b c 2>&1; echo $?
PASS: printf aborts on %r
======================
echo -ne '' >input
echo -ne '' | busybox printf '%0*d\n' 2 1 2>&1; echo $?
PASS: printf treats leading 0 as flag
======================
echo -ne '' >input
echo -ne '' | busybox printf '%0 d\n' 2 2>&1; echo $?
PASS: printf handles multiple flags
PASS: pwd-prints-working-directory
======================
echo -ne '' >input
echo -ne '' | readlink ./readlink_testdir/testfile
PASS: readlink on a file
======================
echo -ne '' >input
echo -ne '' | readlink ./testlink
PASS: readlink on a link
======================
echo -ne '' >input
echo -ne '' | readlink -f ./readlink_testdir/testfile
PASS: readlink -f on a file
======================
echo -ne '' >input
echo -ne '' | readlink -f ./testlink
PASS: readlink -f on a link
======================
echo -ne '' >input
echo -ne '' | readlink -f ./readlink_testdir/readlink_testdir/testlink
PASS: readlink -f on an invalid link
======================
echo -ne '' >input
echo -ne '' | readlink -f readlink_testdir/../readlink_testdir/testfile
PASS: readlink -f on a weird dir
======================
echo -ne '' >input
echo -ne '' | realpath /not_file
PASS: realpath on non-existent absolute path 1
======================
echo -ne '' >input
echo -ne '' | realpath /not_file/
PASS: realpath on non-existent absolute path 2
======================
echo -ne '' >input
echo -ne '' | realpath //not_file
PASS: realpath on non-existent absolute path 3
======================
echo -ne '' >input
echo -ne '' | realpath /not_dir/not_file 2>&1
PASS: realpath on non-existent absolute path 4
======================
echo -ne '' >input
echo -ne '' | realpath realpath_testdir/not_file
PASS: realpath on non-existent local file 1
======================
echo -ne '' >input
echo -ne '' | realpath realpath_testdir/not_dir/not_file 2>&1
PASS: realpath on non-existent local file 2
======================
echo -ne '' >input
echo -ne '' | realpath link1
PASS: realpath on link to non-existent file 1
======================
echo -ne '' >input
echo -ne '' | realpath link2 2>&1
PASS: realpath on link to non-existent file 2
======================
echo -ne '' >input
echo -ne '' | realpath ./link1
PASS: realpath on link to non-existent file 3
======================
echo -ne '' >input
echo -ne '' | realpath ./link2 2>&1
PASS: realpath on link to non-existent file 4
======================
echo -ne 'line 1\n\nline 3\n' >input
echo -ne '' | rev input
PASS: rev works
======================
echo -ne 'line 1\n\nline 3' >input
echo -ne '' | rev input
PASS: rev file with missing newline
======================
echo -ne 'lin\000e 1\n\nline 3\n' >input
echo -ne '' | rev input
PASS: rev file with NUL character
======================
echo -ne '---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+--------------+\nabc\n' >input
echo -ne '' | rev input
PASS: rev file with long line
PASS: rm-removes-file
PASS: rmdir-removes-parent-directories
======================
echo -ne '' >input
echo -ne 'hello\n' | sed ""
PASS: sed no files (stdin)
======================
echo -ne '' >input
echo -ne 'hello\n' | sed "" -
PASS: sed explicit stdin
======================
echo -ne '' >input
echo -ne '\n' | sed -e 's/$/@/'
PASS: sed handles empty lines
======================
echo -ne '' >input
echo -ne 'hello' | sed "" - -
PASS: sed stdin twice
======================
echo -ne '' >input
echo -ne '' | sed -e '1 d'
PASS: sed accepts blanks before command
======================
echo -ne '' >input
echo -ne '2\n' | sed -e 'i1
a3'
PASS: sed accepts newlines in -e
======================
echo -ne '' >input
echo -ne '2\n' | sed -e 'i\' -e '1' -e 'a\' -e '3'
PASS: sed accepts multiple -e
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -n -e s/foo/bar/ -e s/bar/baz/
PASS: sed -n
======================
echo -ne '' >input
echo -ne 'string\n' | sed 's/z*//g'
PASS: sed with empty match
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -e s/foo/bar/p -e s/bar/baz/p
PASS: sed s//p
======================
echo -ne '' >input
echo -ne 'abc\n' | sed -ne s/abc/def/p
PASS: sed -n s//p
======================
echo -ne '' >input
echo -ne '12345\n' | sed -e 's/[[:space:]]*/,/g'
PASS: sed s//g (exhaustive)
======================
echo -ne '' >input
echo -ne 'woo\n' | sed -e 's woo boing '
PASS: sed s arbitrary delimiter
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -e s/foo/bar/ -e s/bar/baz/
PASS: sed s chains
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -e s/foo/bar/ -e s/baz/nee/
PASS: sed s chains2
======================
echo -ne '' >input
echo -ne 'one@two' | sed -e 's@[@]@@'
PASS: sed s [delimiter]
======================
echo -ne '' >input
echo -ne 'one\ttwo' | sed 's/\t/ /'
PASS: sed s with \t (GNU ext)
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -e 'b one;p;: one'
PASS: sed b (branch)
======================
echo -ne '' >input
echo -ne 'foo\n' | sed -e 'b;p'
PASS: sed b (branch with no label jumps to end)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -e 's/a/1/;t one;p;: one;p'
PASS: sed t (test/branch)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -e 's/a/b/;:loop;t loop'
PASS: sed t (test/branch clears test bit)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -e 's/a/1/;T notone;p;: notone;p'
PASS: sed T (!test/branch)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -e 'n;p'
PASS: sed n (flushes pattern space, terminates early)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -e 'N;p'
PASS: sed N (flushes pattern space (GNU behavior))
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed ':a;N;s/\n/ /;ta'
PASS: sed N test2
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed 'N;s/\n/ /'
PASS: sed N test3
======================
echo -ne '' >input
echo -ne 'a\nb\nc\nd\n' | sed "/b/N;/b\\nc/i woo"
PASS: sed address match newline
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed -n 'N;P;p'
PASS: sed N (stops at end of input) and P (prints to first newline only)
======================
echo -ne '' >input
echo -ne 'a\nb\nc\n' | sed G
PASS: sed G (append hold space to pattern space)
======================
echo -ne '' >input
echo -ne 'ook\n' | sed -e '/ook/d;s/ook/ping/p;i woot'
PASS: sed d ends script iteration
======================
echo -ne '' >input
echo -ne 'ook\nwoot\n' | sed -e '/ook/d;a\' -e 'bang'
PASS: sed d ends script iteration (2)
======================
echo -ne '' >input
echo -ne 'woo\0woo\0' | sed -e 's/woo/bang/g'
PASS: sed embedded NUL g
======================
echo -ne 'woo\n' >input
echo -ne 'woo\n' | sed -e 's/woo/bang/' input -
PASS: sed normal newlines
======================
echo -ne 'woo\n' >input
echo -ne 'woo' | sed -e 's/woo/bang/' input -
PASS: sed leave off trailing newline
======================
echo -ne 'woo' >input
echo -ne 'woo' | sed -e 's/woo/bang/' input -
PASS: sed autoinsert newline
======================
echo -ne '' >input
echo -ne 'one\ntwo' | sed -e 's/nohit//' input -
PASS: sed empty file plus cat
======================
echo -ne 'one\ntwo' >input
echo -ne '' | sed -e 's/nohit//' input -
PASS: sed cat plus empty file
======================
echo -ne '' >input
echo -ne 'woot' | sed -e '/woot/a woo' -
PASS: sed append autoinserts newline
======================
echo -ne 'boot' >input
echo -ne 'woot' | sed -e '/oot/a woo' - input
PASS: sed append autoinserts newline 2
======================
echo -ne 'boot' >input
echo -ne '' | sed -e '/oot/a woo' -i input && cat input
PASS: sed append autoinserts newline 3
======================
echo -ne '' >input
echo -ne 'woot' | sed -e '/woot/i woo' -
PASS: sed insert doesn't autoinsert newline
======================
echo -ne '' >input
echo -ne 'one' | sed -e 'p' -
PASS: sed print autoinsert newlines
======================
echo -ne 'one' >input
echo -ne 'two' | sed -e 'p' input -
PASS: sed print autoinsert newlines two files
======================
echo -ne 'no\n' >input
echo -ne '' | sed -ne 's/woo/bang/' input
PASS: sed noprint, no match, no newline
======================
echo -ne 'a woo\nb no' >input
echo -ne 'c woo\nd no' | sed -ne 's/woo/bang/p' input -
PASS: sed selective matches with one nl
======================
echo -ne 'a woo\nb woo' >input
echo -ne 'c no\nd woo' | sed -ne 's/woo/bang/p' input -
PASS: sed selective matches insert newline
======================
echo -ne 'a woo\nb woo' >input
echo -ne 'c no\nd no' | sed -ne 's/woo/bang/p' input -
PASS: sed selective matches noinsert newline
======================
echo -ne 'one' >input
echo -ne 'two' | sed -e '/one/a 111' -e '/two/i 222' -e p input -
PASS: sed clusternewline
======================
echo -ne 'thingy' >input
echo -ne 'again' | sed -e 's/i/z/' -e 'woutputw' input -; /bin/echo -n X; cat outputw
PASS: sed subst+write
======================
echo -ne 'a\0b\0' >input
echo -ne 'c' | sed 's/i/z/' input -
PASS: sed trailing NUL
======================
echo -ne 'a' >input
echo -ne '' | sed 's/a/z\
z/' input
PASS: sed escaped newline in command
======================
echo -ne '' >input
echo -ne 'hello\nthere' | sed -e '$p'
PASS: sed match EOF
======================
echo -ne 'one\ntwo' >input
echo -ne 'three\nfour' | sed -e '$p' input -
PASS: sed match EOF two files
======================
echo -ne 'one\ntwo' >input
echo -ne '' | sed -e '$i ook' -i input input2 && cat input input2
PASS: sed match EOF inline
======================
echo -ne '' >input
echo -ne '' | sed --version | grep -o 'GNU sed version '
PASS: sed lie-to-autoconf
======================
echo -ne '' >input
echo -ne 'woot' | sed -e '/woot/s//eep \0 eep/'
PASS: sed backref from empty s uses range regex
======================
echo -ne '' >input
echo -ne 'woot\n' | sed -e '/woot/s//eep \0 eep/'
PASS: sed backref from empty s uses range regex with newline
======================
echo -ne '' >input
echo -ne '' | sed -e '' -i 2> /dev/null || echo yes
PASS: sed -i with no arg [GNUFAIL]
======================
echo -ne '' >input
echo -ne 'xxx\n' | sed -e 's/xxx/[/'
PASS: sed s/xxx/[/
======================
echo -ne '' >input
echo -ne '0\n1\n2\n3\n' | sed 's/1/x/;T;n;: next;s/3/y/;t quit;n;b next;: quit;q'
PASS: sed n command must reset 'substituted' bit
======================
echo -ne '' >input
echo -ne 'first\nsecond\nthird\nfourth\n' | sed -n '1d;1,3p'
PASS: sed d does not break n,m matching
======================
echo -ne '' >input
echo -ne 'first\nsecond\nthird\nfourth\n' | sed -n '1d;1,/hir/p'
PASS: sed d does not break n,regex matching
======================
echo -ne '' >input
echo -ne 'first\nsecond\nthird\nfourth\nfirst2\nsecond2\nthird2\nfourth2\n' | sed -n '1,5d;1,/hir/p'
PASS: sed d does not break n,regex matching #2
======================
echo -ne '' >input
echo -ne 'first\nsecond\nthird\nfourth\n' | sed -n '2d;2,1p'
PASS: sed 2d;2,1p (gnu compat)
======================
echo -ne '' >input
echo -ne '/usr/lib\n' | sed 's,\(^/\|\)[^/][^/]*,>\0<,g'
PASS: sed beginning (^) matches only once
======================
echo -ne '' >input
echo -ne 'first\nsecond\n' | sed 'crepl'
PASS: sed c
======================
echo -ne '' >input
echo -ne 'qwe\nasd\nzxc\n' | sed '/asd/ { p; /s/ { s/s/c/ }; p; q }'
PASS: sed nested {}s
======================
echo -ne '' >input
echo -ne '| one \\
| two \\
' | sed -e '/| one /a \
| three \\' -e '/| one-/a \
| three-* \\'
PASS: sed a cmd ended by double backslash
======================
echo -ne '' >input
echo -ne 'line1\n' | sed '/1/a\\t\rzero\none\\ntwo\\\nthree'
PASS: sed a cmd understands \n,\t,\r
======================
echo -ne '' >input
echo -ne 'line1\n' | sed '/1/i\\t\rzero\none\\ntwo\\\nthree'
PASS: sed i cmd understands \n,\t,\r
======================
echo -ne '' >input
echo -ne '1\n2\n3\n4\n' | sed -n '1{N;N;d};1p;2,3p;3p;4p'
PASS: sed with N skipping lines past ranges on next cmds
======================
echo -ne 'foo\n' >input
echo -ne '' | cp input input2; sed -i -e '1s/foo/bar/' input input2 && cat input input2; rm input2
PASS: sed -i with address modifies all files, not only first
======================
echo -ne '' >input
echo -ne 'rrr\n' | sed 's/r/\r/'
PASS: sed understands \r
======================
echo -ne '1\n2\n3\n4\n' >input
echo -ne '' | sed '1,2d' -i input; echo $?; cat input
PASS: sed -i finishes ranges correctly
======================
echo -ne '' >input
echo -ne 'helllo\n' | sed 's/l*/@/g'
PASS: sed zero chars match/replace advances correctly 1
======================
echo -ne '' >input
echo -ne ' a.b\n' | sed 's [^ .]* x g'
PASS: sed zero chars match/replace advances correctly 2
======================
echo -ne '' >input
echo -ne '_aaa1aa\n' | sed 's/a/A/g'
PASS: sed zero chars match/replace logic must not falsely trigger here 1
======================
echo -ne '' >input
echo -ne 'qwerty\n' | sed 's/ *$/_/g'
PASS: sed zero chars match/replace logic must not falsely trigger here 2
======================
echo -ne '' >input
echo -ne 'this is a regular line
line with \
continuation
more regular lines
line with \
continuation
' | sed ': testcont; /\\$/{ =; N; b testcont }'
PASS: sed /$_in_regex/ should not match newlines, only end-of-line
======================
echo -ne '' >input
echo -ne 'aa\n' | sed -e 's/a/b/2; s/a/c/g'
PASS: sed s///NUM test
======================
echo -ne '' >input
echo -ne '1\n2\n3\n4\n5\n' | sed /^2/,2{d}
PASS: sed /regex/,N{...} addresses work
======================
echo -ne '' >input
echo -ne '1\n2\n3\n4\n5\n' | sed /^2/,+2{d}
PASS: sed /regex/,+N{...} addresses work
======================
echo -ne '' >input
echo -ne 'a\n1\nc\nc\na\n2\na\n3\n' | sed -n '/a/,+1 p'
PASS: sed /regex/,+N{...} addresses work 2
======================
echo -ne '1\n2\n3\n4\n5\n6\n7\n8\n' >input
echo -ne '1\n2\n4\n5\n6\n7\n8\n' | cat - >input2; sed /^4/,+2{d} -i input input2; echo $?; cat input input2; rm input2
PASS: sed /regex/,+N{...} -i works
======================
echo -ne '1\n2\n3\n4\n5\n6\n7\n8\n' >input
echo -ne '1\n2\n4\n5\n6\n7\n8\n' | cat - >input2; sed /^4/,+0{d} -i input input2; echo $?; cat input input2; rm input2
PASS: sed /regex/,+0{...} -i works
======================
echo -ne '1\n2\n3\n4\n5\n6\n7\n8\n' >input
echo -ne '1\n2\n4\n5\n6\n7\n8\n' | cat - >input2; sed /^4/,+0d -i input input2; echo $?; cat input input2; rm input2
PASS: sed /regex/,+0<cmd> -i works
======================
echo -ne '' >input
echo -ne '123\nqwe\nasd\n' | sed 's/qwe/ZZZ/wz'; cat z; rm z
PASS: sed 's///w FILE'
======================
echo -ne '' >input
echo -ne 'q\nw\ne\nr\n' | sed '/w/p;//q'
PASS: sed uses previous regexp
======================
echo -ne '' >input
echo -ne 'abca\n' | sed -e 's/^a\|b//g'
PASS: sed ^ OR not^
======================
echo -ne '' >input
echo -ne '' | seq 2> /dev/null || echo yes
PASS: seq (exit with error)
======================
echo -ne '' >input
echo -ne '' | seq 1 2 3 4 2> /dev/null || echo yes
PASS: seq (exit with error)
======================
echo -ne '' >input
echo -ne '' | seq 3
PASS: seq one argument
======================
echo -ne '' >input
echo -ne '' | seq 5 7
PASS: seq two arguments
======================
echo -ne '' >input
echo -ne '' | seq 7 5
PASS: seq two arguments reversed
======================
echo -ne '' >input
echo -ne '' | seq 3 3
PASS: seq two arguments equal
======================
echo -ne '' >input
echo -ne '' | seq 1 -15 1
PASS: seq two arguments equal, arbitrary negative step
======================
echo -ne '' >input
echo -ne '' | seq 1 +15 1
PASS: seq two arguments equal, arbitrary positive step
======================
echo -ne '' >input
echo -ne '' | seq 4 2 8
PASS: seq count up by 2
======================
echo -ne '' >input
echo -ne '' | seq 8 -2 4
PASS: seq count down by 2
======================
echo -ne '' >input
echo -ne '' | seq 4 -2 8
PASS: seq count wrong way #1
======================
echo -ne '' >input
echo -ne '' | seq 8 2 4
PASS: seq count wrong way #2
======================
echo -ne '' >input
echo -ne '' | seq 3 .3 4
PASS: seq count by .3
======================
echo -ne '' >input
echo -ne '' | seq 3 .30 4
PASS: seq count by .30
======================
echo -ne '' >input
echo -ne '' | seq 3 .30 4.000
PASS: seq count by .30 to 4.000
======================
echo -ne '' >input
echo -ne '' | seq .7 -.9 -2.2
PASS: seq count by -.9
======================
echo -ne '' >input
echo -ne '' | seq 4 0 8 | head -n 10
PASS: seq count by zero
======================
echo -ne '' >input
echo -ne '' | seq -w 003
PASS: seq one argument with padding
======================
echo -ne '' >input
echo -ne '' | seq -w 005 7
PASS: seq two arguments with padding
======================
echo -ne '' >input
echo -ne '' | seq -w 8 -3 04
PASS: seq count down by 3 with padding
======================
echo -ne '' >input
echo -ne '' | seq -w 09 .3 11
PASS: seq count by .3 with padding 1
======================
echo -ne '' >input
echo -ne '' | seq -w 03 .3 0004
PASS: seq count by .3 with padding 2
PASS: sha1sum
PASS: sha1sum -c EMPTY
PASS: sha256sum
PASS: sha256sum -c EMPTY
PASS: sha3sum
PASS: sha3sum -c EMPTY
PASS: sha512sum
PASS: sha512sum -c EMPTY
======================
echo -ne 'c\na\nb\n' >input
echo -ne '' | sort input
PASS: sort
======================
echo -ne '3\n1\n010\n' >input
echo -ne '' | sort input
PASS: sort #2
======================
echo -ne '' >input
echo -ne 'b\na\nc\n' | sort
PASS: sort stdin
======================
echo -ne '3\n1\n010\n' >input
echo -ne '' | sort -n input
PASS: sort numeric
======================
echo -ne 'point\nwook\npabst\naargh\nwalrus\n' >input
echo -ne '' | sort -r input
PASS: sort reverse
======================
echo -ne '4213woot
421010zoology
egg12papyrus
7342soup
99930algebra
' >input
echo -ne '' | sort -k4,4 input
PASS: sort one key
======================
echo -ne '4213woot
421010zoology
egg12papyrus
7342soup
99930algebra
' >input
echo -ne '' | sort -k2,3n input
PASS: sort key range with numeric option
======================
echo -ne '4213woot
421010zoology
egg12papyrus
7342soup
99930algebra
' >input
echo -ne '' | sort -k2,3n -r input
PASS: sort key range with numeric option and global reverse
======================
echo -ne '4213woot
421010zoology
egg12papyrus
7342soup
99930algebra
' >input
echo -ne '' | sort -k2,3rn input
PASS: sort key range with multiple options
======================
echo -ne 'c 3
b 2
d 2
' >input
echo -ne '' | sort -k 2,2n -k 1,1r input
PASS: sort key range with two -k options
======================
echo -ne '/a/2
/b/1
' >input
echo -ne '' | sort -n -k2 -t/ input
PASS: sort with non-default leading delim 1
======================
echo -ne '/b/1
/a/2
' >input
echo -ne '' | sort -n -k3 -t/ input
PASS: sort with non-default leading delim 2
======================
echo -ne '//a/2
//b/1
' >input
echo -ne '' | sort -n -k3 -t/ input
PASS: sort with non-default leading delim 3
======================
echo -ne 'a/a:a
a:b
' >input
echo -ne '' | sort -t: -k1,1 input
PASS: sort with non-default leading delim 4
======================
echo -ne 'aa.2
ab.1
' >input
echo -ne '' | sort -t. -k1,1.1 -k2 input
PASS: sort with ENDCHAR
======================
echo -ne 'GLIBC_2.21
GLIBC_2.1.1
GLIBC_2.2.1
GLIBC_2.2
GLIBC_2.20
GLIBC_2.10
GLIBC_2.1
' >input
echo -ne '' | sort -t. -k 1,1 -k 2n,2n -k 3 input
PASS: glibc build sort
======================
echo -ne 'GLIBC_2.10
GLIBC_2.2.1
GLIBC_2.1.1
GLIBC_2.20
GLIBC_2.2
GLIBC_2.1
GLIBC_2.21
' >input
echo -ne '' | sort -u -t. -k 1,1 -k 2n,2n -k 3 input
PASS: glibc build sort unique
======================
echo -ne 'a c
b c
' >input
echo -ne '' | sort -u -k2 input
PASS: sort -u should consider field only when discarding
======================
echo -ne 'one\0two\0three\0' >input
echo -ne '' | sort -z input
PASS: sort -z outputs NUL terminated lines
======================
echo -ne '' >input
echo -ne ' 2 \n 1 \n a \n' | sort -n -k2 -t ' '
PASS: sort key doesn't strip leading blanks, disables fallback global sort
======================
echo -ne '222
111
' >input
echo -ne '' | sort -o input input && cat input
PASS: sort file in place
FAIL: strings-works-like-GNU
+ rm -f foo bar
+ strings -af ../../busybox
/usr/share/busybox/testsuite/strings/strings-works-like-GNU: line 2: strings: command not found
======================
echo -ne '' >input
echo -ne '' | sum -r '/usr/share/busybox/testsuite/sum.tests' | grep -c '/usr/share/busybox/testsuite/sum.tests' && echo wrongly_printed_filename || echo yes
PASS: sum -r file doesn't print file's name
======================
echo -ne '' >input
echo -ne '' | sum -r '/usr/share/busybox/testsuite/sum.tests' '/usr/share/busybox/testsuite/sum.tests' | grep -c '/usr/share/busybox/testsuite/sum.tests' && echo yes || echo wrongly_omitted_filename
PASS: sum -r file file does print both names
======================
echo -ne '' >input
echo -ne '' | sum -s '/usr/share/busybox/testsuite/sum.tests' | grep -c '/usr/share/busybox/testsuite/sum.tests' && echo yes || echo wrongly_omitted_filename
PASS: sum -s file does print file's name
PASS: tail-n-works
PASS: tail-works
======================
echo -ne '' >input
echo -ne 'qw' | tail -c +55 2>&1; echo $?
PASS: tail: +N with N > file length
======================
echo -ne '' >input
echo -ne '' | 
dd if=/dev/zero bs=16k count=1 2>/dev/null | tail -c +8200 | wc -c;
dd if=/dev/zero bs=16k count=1 2>/dev/null | tail -c +8208 | wc -c;

PASS: tail: -c +N with largish N
PASS: tar-archives-multiple-files
PASS: tar-complains-about-missing-file
PASS: tar-demands-at-least-one-ctx
PASS: tar-demands-at-most-one-ctx
PASS: tar-extracts-all-subdirs
PASS: tar-extracts-file
PASS: tar-extracts-from-standard-input
PASS: tar-extracts-multiple-files
PASS: tar-extracts-to-standard-output
PASS: tar-handles-cz-options
PASS: tar-handles-empty-include-and-non-empty-exclude-list
PASS: tar-handles-exclude-and-extract-lists
PASS: tar-handles-multiple-X-options
PASS: tar-handles-nested-exclude
PASS: tar_with_link_with_size
PASS: tar_with_prefix_fields
======================
echo -ne '' >input
echo -ne '' | \
tar xvf - 2>&1; echo $?

PASS: tar Empty file is not a tarball
======================
echo -ne '' >input
echo -ne '' | \
{ tar xvzf - 2>&1; echo $?; } | grep -Fv "invalid magic"

PASS: tar Empty file is not a tarball.tar.gz
======================
echo -ne '' >input
echo -ne '' | \
dd if=/dev/zero bs=512 count=2 2>/dev/null | tar xvf - 2>&1; echo $?

PASS: tar Two zeroed blocks is a ('truncated') empty tarball
======================
echo -ne '' >input
echo -ne '' | \
dd if=/dev/zero bs=512 count=20 2>/dev/null | tar xvf - 2>&1; echo $?

PASS: tar Twenty zeroed blocks is an empty tarball
======================
echo -ne '' >input
echo -ne '' | \
>input_hard1
ln input_hard1 input_hard2
mkdir input_dir
>input_dir/file
chmod -R 644 *
chmod    755 input_dir
tar cf test.tar input input_dir/ input_hard1 input_hard2 input_hard1 input_dir/ input
tar tvf test.tar | sed "s/.*[0-9] input/input/"
rm -rf input_dir
tar xf test.tar 2>&1
echo Ok: $?
ls -l . input_dir/* | grep input_ | sed "s/\\(^[^ ]*\\) .* input/\\1 input/"

PASS: tar hardlinks and repeated files
======================
echo -ne '' >input
echo -ne '' | \
>input_hard1
chmod 741 input_hard1
ln input_hard1 input_hard2
mkdir input_dir
ln input_hard1 input_dir
ln input_hard2 input_dir
chmod 550 input_dir
# On some filesystems, input_dir/input_hard2 is returned by readdir
# BEFORE input_dir/input_hard1! Thats why we cant just "tar cf ... input_*":
tar cf test.tar input_dir/input_hard* input_hard*
tar tvf test.tar | sed "s/.*[0-9] input/input/"
chmod 770 input_dir
rm -rf input_*
tar xf test.tar 2>&1
echo Ok: $?
ls -l . input_dir/* | grep "input.*hard" | sed "s/\\(^[^ ]*\\) .* input/\\1 input/"

PASS: tar hardlinks mode
======================
echo -ne '' >input
echo -ne '' | \
>input_file
chmod 741 input_file
ln -s input_file input_soft
mkdir input_dir
ln input_file input_dir
ln input_soft input_dir
chmod 550 input_dir
tar cf test.tar input_dir/* input_[fs]*
tar tvf test.tar | sed "s/.*[0-9] input/input/" | sort
chmod 770 input_dir
rm -rf input_*
tar xf test.tar 2>&1
echo Ok: $?
ls -l . input_dir/* | grep "input_[fs]" | sed "s/\\(^[^ ]*\\) .* input/\\1 input/"

PASS: tar symlinks mode
======================
echo -ne 'Ok\n' >input
echo -ne '' | ln input input_hard
tar cf test.tar input_hard
echo WRONG >input
# --overwrite opens 'input_hard' without unlinking,
# thus 'input_hard' still linked to 'input' and we write 'Ok' into it
tar xf test.tar --overwrite 2>&1 && cat input

PASS: tar --overwrite
======================
echo -ne '' >input
echo -ne '' | dd count=1 bs=1M if=/dev/zero of=F0 2>/dev/null
tar -czf F0.tgz F0
rm F0
tar -xzvf F0.tgz && echo Ok
rm F0 || echo BAD

PASS: tar extract tgz
SKIPPED: tar extract txz
======================
echo -ne '' >input
echo -ne '' | rm -rf input_* test.tar 2>/dev/null
mkdir input_dir
echo Ok >input_dir/file
tar cf test.tar ./../tar.tempdir/input_dir/../input_dir 2>&1
rm -rf input_* 2>/dev/null
tar -vxf test.tar 2>&1
cat input_dir/file 2>&1

PASS: tar strips /../ on extract
SKIPPED: tar does not extract into symlinks
SKIPPED: tar -k does not extract into symlinks
SKIPPED: tar Pax-encoded UTF8 names and symlinks
SKIPPED: tar Symlink attack: create symlink and then write through it
======================
echo -ne '' >input
echo -ne '' | \
mkdir dir
>dir/a
ln -s ../dir/a dir/b
ln dir/b dir/c
mkdir new
tar cf - dir/* | tar -C new -xvf - 2>&1

PASS: tar Symlinks and hardlinks coexist
PASS: tee-appends-input
PASS: tee-tees-input
======================
echo -ne '' >input
echo -ne '' | busybox test; echo $?
PASS: test: should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test ''; echo $?
PASS: test '': should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test !; echo $?
PASS: test !: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test a; echo $?
PASS: test a: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test --help; echo $?
PASS: test --help: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test -f; echo $?
PASS: test -f: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test ! -f; echo $?
PASS: test ! -f: should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test a = a; echo $?
PASS: test a = a: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test -lt = -gt; echo $?
PASS: test -lt = -gt: should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test a -a !; echo $?
PASS: test a -a !: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test -f = a -o b; echo $?
PASS: test -f = a -o b: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test ! a = b -a ! c = c; echo $?
PASS: test ! a = b -a ! c = c: should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test ! a = b -a ! c = d; echo $?
PASS: test ! a = b -a ! c = d: should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test '!' = '!'; echo $?
PASS: test '!' = '!': should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test '(' = '('; echo $?
PASS: test '(' = '(': should be true (0)
======================
echo -ne '' >input
echo -ne '' | busybox test '!' '!' = '!'; echo $?
PASS: test '!' '!' = '!': should be false (1)
======================
echo -ne '' >input
echo -ne '' | busybox test '!' '(' = '('; echo $?
PASS: test '!' '(' = '(': should be false (1)
PASS: touch-creates-file
PASS: touch-does-not-create-file
PASS: touch-touches-files-after-non-existent-file
PASS: tr-d-alnum-works
PASS: tr-d-works
PASS: tr-non-gnu
PASS: tr-rejects-wrong-class
PASS: tr-works
======================
echo -ne '' >input
echo -ne '[qwe]' | tr '[q-z]' '_Q-Z+'
PASS: tr does not treat [] in [a-z] as special
======================
echo -ne '' >input
echo -ne '19AFH\n' | tr -cd '[0-9A-F]'
PASS: tr understands 0-9A-F
======================
echo -ne '' >input
echo -ne '19AFH\n' | tr -cd '[:xdigit:]'
PASS: tr understands [:xdigit:]
======================
echo -ne '' >input
echo -ne '789abcxyz\n' | tr '[:digit:]y-z' 111111111123
PASS: tr does not stop after [:digit:]
======================
echo -ne '' >input
echo -ne '#0123456789ABCDEFGabcdefg\n' | tr '[:xdigit:]Gg' 1111111151242222333330xX
PASS: tr has correct xdigit sequence
PASS: true-is-silent
PASS: true-returns-success
======================
echo -ne '' >input
echo -ne '\x1f\x9d\x90\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01\01' | uncompress 2>&1 1>/dev/null; echo $?
PASS: uncompress < \x1f\x9d\x90 \x01 x N
======================
echo -ne '' >input
echo -ne '        12345678\n' | unexpand
PASS: unexpand case 1
======================
echo -ne '' >input
echo -ne '         12345678\n' | unexpand
PASS: unexpand case 2
======================
echo -ne '' >input
echo -ne '          12345678\n' | unexpand
PASS: unexpand case 3
======================
echo -ne '' >input
echo -ne '       \t12345678\n' | unexpand
PASS: unexpand case 4
======================
echo -ne '' >input
echo -ne '      \t12345678\n' | unexpand
PASS: unexpand case 5
======================
echo -ne '' >input
echo -ne '     \t12345678\n' | unexpand
PASS: unexpand case 6
======================
echo -ne '' >input
echo -ne '123 \t 45678\n' | unexpand
PASS: unexpand case 7
======================
echo -ne '' >input
echo -ne 'a b\n' | unexpand
PASS: unexpand case 8
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand 
PASS: unexpand flags 
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -f
PASS: unexpand flags -f
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -f -t8
PASS: unexpand flags -f -t8
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -t8 -f
PASS: unexpand flags -t8 -f
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -t8 --first-only
PASS: unexpand flags -t8 --first-only
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -a
PASS: unexpand flags -a
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -t8
PASS: unexpand flags -t8
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -a -t8
PASS: unexpand flags -a -t8
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -t4
PASS: unexpand flags -t4
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -a -t4
PASS: unexpand flags -a -t4
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -t4 -a
PASS: unexpand flags -t4 -a
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -t4 -f
PASS: unexpand flags -t4 -f
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -f -t4
PASS: unexpand flags -f -t4
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand -t4 --first-only
PASS: unexpand flags -t4 --first-only
======================
echo -ne '' >input
echo -ne '        a       b    c' | unexpand --first-only -t4
PASS: unexpand flags --first-only -t4
======================
echo -ne '' >input
echo -ne '1ΔΔΔ5   99999\n' | unexpand
PASS: unexpand with unicode characher 0x394
======================
echo -ne '' >input
echo -ne '' | uniq nonexistent 2> /dev/null || echo yes
PASS: uniq (exit with error)
======================
echo -ne '' >input
echo -ne '' | uniq /dev/null && echo yes
PASS: uniq (exit success)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq
PASS: uniq (default to stdin)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq -
PASS: uniq - (specify stdin)
======================
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' >input
echo -ne '' | uniq input
PASS: uniq input (specify file)
======================
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' >input
echo -ne '' | uniq input actual > /dev/null
PASS: uniq input outfile (two files)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq - actual
PASS: uniq (stdin) outfile
======================
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' >input
echo -ne '' | uniq input -
PASS: uniq input - (specify stdout)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq -c | sed 's/^[ \t]*//'
PASS: uniq -c (occurrence count)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq -d
PASS: uniq -d (dups only)
======================
echo -ne '' >input
echo -ne 'ccddee8
bbccdd8
aabbcc9
' | uniq -f2 -s 3
PASS: uniq -f -s (skip fields and chars)
======================
echo -ne '' >input
echo -ne 'cc1
cc2
cc3
' | uniq -w 2
PASS: uniq -w (compare max characters)
======================
echo -ne '' >input
echo -ne 'aaccaa
aaccbb
bbccaa
' | uniq -s 2 -w 2
PASS: uniq -s -w (skip fields and compare max chars)
======================
echo -ne '' >input
echo -ne 'one\ntwo\ntwo\nthree\nthree\nthree\n' | uniq -d -u
PASS: uniq -u and -d produce no output
======================
echo -ne '' >input
echo -ne '' | unlzma <unlzma_issue_1.lzma 2>&1 >/dev/null; echo $?
PASS: unlzma (bad archive 1)
======================
echo -ne '' >input
echo -ne '' | unlzma <unlzma_issue_2.lzma 2>&1 >/dev/null; echo $?
PASS: unlzma (bad archive 2)
======================
echo -ne '' >input
echo -ne '' | unlzma <unlzma_issue_3.lzma 2>&1 >/dev/null; echo $?
PASS: unlzma (bad archive 3)
======================
echo -ne '' >input
echo -ne '' | unzip -q foo.zip foo/ && test -d foo && test ! -f foo/bar && echo yes
PASS: unzip (subdir only)
SKIPPED: unzip (bad archive)
======================
echo -ne '' >input
echo -ne '' | unzip -p ../unzip_bad_lzma_1.zip 2>&1; echo $?
PASS: unzip (archive with corrupted lzma 1)
======================
echo -ne '' >input
echo -ne '' | unzip -p ../unzip_bad_lzma_2.zip 2>&1; echo $?
PASS: unzip (archive with corrupted lzma 2)
PASS: uptime-works
======================
echo -ne '' >input
echo -ne '' | uuencode foo </dev/null | head -n 1 | grep -q 666 && echo yes
PASS: uuencode sets standard input mode correctly
======================
echo -ne '' >input
echo -ne 'The fast grey fox jumped over the lazy brown dog.\n' | uuencode bb_uuenc_test.out
PASS: uuencode correct encoding
======================
echo -ne '' >input
echo -ne 'The fast grey fox jumped over the lazy brown dog.\n' | uuencode -m bb_uuenc_test.out
PASS: uuencode correct base64 encoding
======================
echo -ne '' >input
echo -ne '' | r=`uuencode FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode empty file
======================
echo -ne '' >input
echo -ne '' | r=`uuencode -m FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode -m empty file
======================
echo -ne '' >input
echo -ne 'A' | r=`uuencode FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode file 'A'
======================
echo -ne '' >input
echo -ne 'A' | r=`uuencode -m FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode -m file 'A'
======================
echo -ne '' >input
echo -ne 'AB' | r=`uuencode FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode file 'AB'
======================
echo -ne '' >input
echo -ne 'AB' | r=`uuencode -m FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode -m file 'AB'
======================
echo -ne '' >input
echo -ne 'ABC' | r=`uuencode FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode file 'ABC'
======================
echo -ne '' >input
echo -ne 'ABC' | r=`uuencode -m FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode -m file 'ABC'
======================
echo -ne '' >input
echo -ne 'ABCD' | r=`uuencode FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode file 'ABCD'
======================
echo -ne '' >input
echo -ne 'ABCD' | r=`uuencode -m FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode -m file 'ABCD'
======================
echo -ne '' >input
echo -ne 'ABCDE' | r=`uuencode FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode file 'ABCDE'
======================
echo -ne '' >input
echo -ne 'ABCDE' | r=`uuencode -m FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode -m file 'ABCDE'
======================
echo -ne '' >input
echo -ne 'ABCDEF' | r=`uuencode FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode file 'ABCDEF'
======================
echo -ne '' >input
echo -ne 'ABCDEF' | r=`uuencode -m FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode -m file 'ABCDEF'
======================
echo -ne '' >input
echo -ne 'A\x0\xffZ' | r=`uuencode FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode file 'A<NUL><0xff>Z'
======================
echo -ne '' >input
echo -ne 'A\x0\xffZ' | r=`uuencode -m FILE`; echo "$r"; echo "$r" | uudecode -o -;
PASS: uuencode -m file 'A<NUL><0xff>Z'
PASS: wc-counts-all
PASS: wc-counts-characters
PASS: wc-counts-lines
PASS: wc-counts-words
PASS: wc-prints-longest-line-length
PASS: wget--O-overrides--P
PASS: wget-handles-empty-path
PASS: wget-retrieves-google-index
PASS: wget-supports--P
PASS: which-uses-default-path
PASS: xargs-works
======================
echo -ne '' >input
echo -ne 'a\n_\nb\n' | xargs -E _
PASS: xargs -E _ stops on underscore
======================
echo -ne '' >input
echo -ne 'a\n_\nb\n' | xargs -E ''
PASS: xargs -E ''
======================
echo -ne '' >input
echo -ne 'a\n_\nb\n' | xargs -e
PASS: xargs -e without param
======================
echo -ne '' >input
echo -ne 'a\n_\nb\n' | xargs
PASS: xargs does not stop on underscore ('new' GNU behavior)
======================
echo -ne '' >input
echo -ne 'a\n' | xargs -s7 echo
PASS: xargs -s7 can take one-char input
======================
echo -ne '' >input
echo -ne '1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 00\n' | xargs -ts25 echo 2>&1 >/dev/null
PASS: xargs -sNUM test 1
======================
echo -ne '' >input
echo -ne '2 3 4 5 6 7 8 9 0 2 3 4 5 6 7 8 9 00\n' | xargs -ts25 echo 1 2>&1 >/dev/null
PASS: xargs -sNUM test 2
======================
echo -ne '' >input
echo -ne '' | seq 10000 99999 | sed -e 's/^/"/' -e 's/$/"/' | xargs echo | grep -o 99999; echo $?
PASS: xargs argument line too long
======================
echo -ne '' >input
echo -ne '1 2 3 4 5\n' | xargs -n1 echo
PASS: xargs -n1
======================
echo -ne '' >input
echo -ne '1 2 3 4 5\n' | xargs -n2 echo
PASS: xargs -n2
======================
echo -ne '' >input
echo -ne ' \n2\n\n4\n\n 6 6 \n \v \t 7\n\t\n\v\n' | xargs -I% echo '[%]'
PASS: xargs -I skips empty lines and leading whitespace
======================
echo -ne '' >input
echo -ne '\0' | xxd -p
PASS: xxd -p with one NUL
======================
echo -ne '' >input
echo -ne '\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0' | xxd -p
PASS: xxd -p with 30 NULs
======================
echo -ne '' >input
echo -ne '\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0' | xxd -p
PASS: xxd -p with 31 NULs
======================
echo -ne '' >input
echo -ne '30313233343536373736353433323130 30313233343536373736353433323130' | xxd -p -r
PASS: xxd -p -r
